{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Syst\u00e8me d'extraction automatique de trajets \u00e0 partir de phrases en fran\u00e7ais utilisant le NLP et les transformers. \ud83c\udfaf Objectif du projet Trip Extraction est un syst\u00e8me de traitement du langage naturel (NLP) con\u00e7u pour extraire automatiquement les informations de voyage (villes de d\u00e9part et d'arriv\u00e9e) depuis des phrases en fran\u00e7ais naturel. Le syst\u00e8me combine deux mod\u00e8les de deep learning pour obtenir une pr\u00e9cision de 95%+ : CamemBERT-NER : D\u00e9tection des entit\u00e9s nomm\u00e9es (villes) Classifier personnalis\u00e9 : Classification d\u00e9part vs arriv\u00e9e \u2728 Fonctionnalit\u00e9s Extraction intelligente Reconnaissance d'entit\u00e9s nomm\u00e9es (NER) : D\u00e9tection automatique des villes avec CamemBERT Classification contextuelle : Identification pr\u00e9cise du r\u00f4le (d\u00e9part/arriv\u00e9e) de chaque ville Support multi-syntaxe : G\u00e8re les questions, syntaxe invers\u00e9e, contexte temporel Interface compl\u00e8te CLI interactif : Demo en ligne de commande avec retour visuel API Python : Int\u00e9gration simple dans vos projets Gestion d'erreurs : Exceptions typ\u00e9es pour un debugging facile Performance Haute pr\u00e9cision : 95%+ sur le dataset de test Rapide : 0.1-0.5s par phrase selon le hardware Optimis\u00e9 : Support CPU et GPU (CUDA) \ud83d\ude80 Installation rapide Fish Shell # Cloner et installer git clone <repo-url> cd bootstrap python -m venv .venv source .venv/bin/activate.fish pip install -e . # Entra\u00eener le mod\u00e8le (obligatoire premi\u00e8re fois) trip-train # Lancer le demo trip-demo Bash/Zsh # Cloner et installer git clone <repo-url> cd bootstrap python -m venv .venv source .venv/bin/activate pip install -e . # Entra\u00eener le mod\u00e8le (obligatoire premi\u00e8re fois) trip-train # Lancer le demo trip-demo \ud83d\udca1 Exemple d'utilisation from trip import TripParser # Initialiser le parser parser = TripParser() # Extraire un trajet departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"D\u00e9part: {departure}\") print(f\"Arriv\u00e9e: {arrival}\") Exemples de phrases support\u00e9es Le syst\u00e8me g\u00e8re une grande vari\u00e9t\u00e9 de formulations : # Syntaxe simple \"De Paris \u00e0 Lyon\" \u2192 Paris \u2192 Lyon \"Paris Lyon\" \u2192 Paris \u2192 Lyon # Questions \"Comment aller \u00e0 Marseille depuis Toulouse ?\" \u2192 Toulouse \u2192 Marseille \"O\u00f9 prendre le train pour Nice ?\" \u2192 <ville actuelle> \u2192 Nice # Syntaxe invers\u00e9e \"\u00c0 Lille depuis Paris\" \u2192 Paris \u2192 Lille \"Vers Lyon de Paris\" \u2192 Paris \u2192 Lyon # Avec contexte temporel \"Demain je vais de Nice \u00e0 Cannes\" \u2192 Nice \u2192 Cannes \"Train de 8h de Paris \u00e0 Lyon\" \u2192 Paris \u2192 Lyon \ud83d\udcca Performance Composant M\u00e9trique Score NER Extractor Precision 95% NER Extractor Recall 93% NER Extractor F1-Score 94% Classifier Accuracy 96% Classifier Precision 97% Classifier F1-Score 98% Temps d'ex\u00e9cution Device Temps par phrase CPU 0.3-0.5s GPU (CUDA) 0.1-0.2s \ud83c\udfd7\ufe0f Architecture Input: \"Je vais de Paris \u00e0 Lyon\" \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 NER Extractor \u2502 \u2192 D\u00e9tecte: [\"Paris\", \"Lyon\"] \u2502 (CamemBERT-NER) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Classifier \u2502 \u2192 Paris: departure (98%) \u2502 (CamemBERT custom) \u2502 \u2192 Lyon: arrival (97%) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 Output: (Paris, Lyon) Composants principaux : - TripParser : Orchestration et validation - NERExtractor : Extraction des villes avec CamemBERT-NER - DepartureArrivalClassifier : Classification avec CamemBERT fine-tun\u00e9 - Exceptions : Gestion d'erreurs typ\u00e9es \ud83d\udcda Navigation Installation compl\u00e8te Guide d'installation d\u00e9taill\u00e9 avec : Pr\u00e9requis syst\u00e8me Installation standard et d\u00e9veloppement Configuration GPU/CUDA Troubleshooting Guide d'utilisation Exemples et API avec : Interface CLI API Python avec exemples codexec Batch processing Configuration avanc\u00e9e Architecture technique Vue d'ensemble architecture avec : Description des composants Pipeline de traitement Format du dataset Performance d\u00e9taill\u00e9e R\u00e9f\u00e9rence API Documentation API compl\u00e8te avec : API auto-g\u00e9n\u00e9r\u00e9e via mkdocstrings Classes et m\u00e9thodes document\u00e9es Signatures de types Exemples interactifs \ud83c\udf93 Cas d'usage Trip Extraction peut \u00eatre utilis\u00e9 pour : Chatbots de voyage : Extraction automatique de trajets depuis messages utilisateurs Syst\u00e8mes de r\u00e9servation : Parsing de requ\u00eates en langage naturel Analyse de donn\u00e9es : Extraction de trajets depuis corpus de textes Assistants virtuels : Compr\u00e9hension d'intentions de voyage Applications mobiles : Interface vocale pour recherche de trajets \ud83d\udd27 D\u00e9veloppement Pour contribuer au projet : # Installation avec outils de dev pip install -e \".[dev]\" # Formattage et linting black src/ scripts/ ruff check src/ scripts/ mypy src/ Outils inclus : black , ruff , mypy , pytest , jupyter","title":"Accueil"},{"location":"#objectif-du-projet","text":"Trip Extraction est un syst\u00e8me de traitement du langage naturel (NLP) con\u00e7u pour extraire automatiquement les informations de voyage (villes de d\u00e9part et d'arriv\u00e9e) depuis des phrases en fran\u00e7ais naturel. Le syst\u00e8me combine deux mod\u00e8les de deep learning pour obtenir une pr\u00e9cision de 95%+ : CamemBERT-NER : D\u00e9tection des entit\u00e9s nomm\u00e9es (villes) Classifier personnalis\u00e9 : Classification d\u00e9part vs arriv\u00e9e","title":"\ud83c\udfaf Objectif du projet"},{"location":"#fonctionnalites","text":"","title":"\u2728 Fonctionnalit\u00e9s"},{"location":"#extraction-intelligente","text":"Reconnaissance d'entit\u00e9s nomm\u00e9es (NER) : D\u00e9tection automatique des villes avec CamemBERT Classification contextuelle : Identification pr\u00e9cise du r\u00f4le (d\u00e9part/arriv\u00e9e) de chaque ville Support multi-syntaxe : G\u00e8re les questions, syntaxe invers\u00e9e, contexte temporel","title":"Extraction intelligente"},{"location":"#interface-complete","text":"CLI interactif : Demo en ligne de commande avec retour visuel API Python : Int\u00e9gration simple dans vos projets Gestion d'erreurs : Exceptions typ\u00e9es pour un debugging facile","title":"Interface compl\u00e8te"},{"location":"#performance","text":"Haute pr\u00e9cision : 95%+ sur le dataset de test Rapide : 0.1-0.5s par phrase selon le hardware Optimis\u00e9 : Support CPU et GPU (CUDA)","title":"Performance"},{"location":"#installation-rapide","text":"Fish Shell # Cloner et installer git clone <repo-url> cd bootstrap python -m venv .venv source .venv/bin/activate.fish pip install -e . # Entra\u00eener le mod\u00e8le (obligatoire premi\u00e8re fois) trip-train # Lancer le demo trip-demo Bash/Zsh # Cloner et installer git clone <repo-url> cd bootstrap python -m venv .venv source .venv/bin/activate pip install -e . # Entra\u00eener le mod\u00e8le (obligatoire premi\u00e8re fois) trip-train # Lancer le demo trip-demo","title":"\ud83d\ude80 Installation rapide"},{"location":"#exemple-dutilisation","text":"from trip import TripParser # Initialiser le parser parser = TripParser() # Extraire un trajet departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"D\u00e9part: {departure}\") print(f\"Arriv\u00e9e: {arrival}\")","title":"\ud83d\udca1 Exemple d'utilisation"},{"location":"#exemples-de-phrases-supportees","text":"Le syst\u00e8me g\u00e8re une grande vari\u00e9t\u00e9 de formulations : # Syntaxe simple \"De Paris \u00e0 Lyon\" \u2192 Paris \u2192 Lyon \"Paris Lyon\" \u2192 Paris \u2192 Lyon # Questions \"Comment aller \u00e0 Marseille depuis Toulouse ?\" \u2192 Toulouse \u2192 Marseille \"O\u00f9 prendre le train pour Nice ?\" \u2192 <ville actuelle> \u2192 Nice # Syntaxe invers\u00e9e \"\u00c0 Lille depuis Paris\" \u2192 Paris \u2192 Lille \"Vers Lyon de Paris\" \u2192 Paris \u2192 Lyon # Avec contexte temporel \"Demain je vais de Nice \u00e0 Cannes\" \u2192 Nice \u2192 Cannes \"Train de 8h de Paris \u00e0 Lyon\" \u2192 Paris \u2192 Lyon","title":"Exemples de phrases support\u00e9es"},{"location":"#performance_1","text":"Composant M\u00e9trique Score NER Extractor Precision 95% NER Extractor Recall 93% NER Extractor F1-Score 94% Classifier Accuracy 96% Classifier Precision 97% Classifier F1-Score 98%","title":"\ud83d\udcca Performance"},{"location":"#temps-dexecution","text":"Device Temps par phrase CPU 0.3-0.5s GPU (CUDA) 0.1-0.2s","title":"Temps d'ex\u00e9cution"},{"location":"#architecture","text":"Input: \"Je vais de Paris \u00e0 Lyon\" \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 NER Extractor \u2502 \u2192 D\u00e9tecte: [\"Paris\", \"Lyon\"] \u2502 (CamemBERT-NER) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Classifier \u2502 \u2192 Paris: departure (98%) \u2502 (CamemBERT custom) \u2502 \u2192 Lyon: arrival (97%) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 Output: (Paris, Lyon) Composants principaux : - TripParser : Orchestration et validation - NERExtractor : Extraction des villes avec CamemBERT-NER - DepartureArrivalClassifier : Classification avec CamemBERT fine-tun\u00e9 - Exceptions : Gestion d'erreurs typ\u00e9es","title":"\ud83c\udfd7\ufe0f Architecture"},{"location":"#navigation","text":"Installation compl\u00e8te Guide d'installation d\u00e9taill\u00e9 avec : Pr\u00e9requis syst\u00e8me Installation standard et d\u00e9veloppement Configuration GPU/CUDA Troubleshooting Guide d'utilisation Exemples et API avec : Interface CLI API Python avec exemples codexec Batch processing Configuration avanc\u00e9e Architecture technique Vue d'ensemble architecture avec : Description des composants Pipeline de traitement Format du dataset Performance d\u00e9taill\u00e9e R\u00e9f\u00e9rence API Documentation API compl\u00e8te avec : API auto-g\u00e9n\u00e9r\u00e9e via mkdocstrings Classes et m\u00e9thodes document\u00e9es Signatures de types Exemples interactifs","title":"\ud83d\udcda Navigation"},{"location":"#cas-dusage","text":"Trip Extraction peut \u00eatre utilis\u00e9 pour : Chatbots de voyage : Extraction automatique de trajets depuis messages utilisateurs Syst\u00e8mes de r\u00e9servation : Parsing de requ\u00eates en langage naturel Analyse de donn\u00e9es : Extraction de trajets depuis corpus de textes Assistants virtuels : Compr\u00e9hension d'intentions de voyage Applications mobiles : Interface vocale pour recherche de trajets","title":"\ud83c\udf93 Cas d'usage"},{"location":"#developpement","text":"Pour contribuer au projet : # Installation avec outils de dev pip install -e \".[dev]\" # Formattage et linting black src/ scripts/ ruff check src/ scripts/ mypy src/ Outils inclus : black , ruff , mypy , pytest , jupyter","title":"\ud83d\udd27 D\u00e9veloppement"},{"location":"api/","text":"Documentation compl\u00e8te de l'API Trip Extraction g\u00e9n\u00e9r\u00e9e automatiquement depuis le code source. Vue d'ensemble Trip Extraction expose trois composants principaux : TripParser : Point d'entr\u00e9e pour l'extraction de trajets NERExtractor : Extraction d'entit\u00e9s nomm\u00e9es (villes) DepartureArrivalClassifier : Classification d\u00e9part/arriv\u00e9e Exceptions : Gestion d'erreurs typ\u00e9es TripParser trip.trip_parser.TripParser Parser for extracting trip information (departure and arrival) from text. Uses two specialized models: 1. NER model (CamemBERT) to identify locations (LOC entities) 2. Custom fine-tuned classifier to determine departure vs arrival This approach provides optimized, fast, and reliable trip extraction. Source code in src/trip/trip_parser.py class TripParser: \"\"\" Parser for extracting trip information (departure and arrival) from text. Uses two specialized models: 1. NER model (CamemBERT) to identify locations (LOC entities) 2. Custom fine-tuned classifier to determine departure vs arrival This approach provides optimized, fast, and reliable trip extraction. \"\"\" def __init__( self, ner_extractor: Optional[NERExtractor] = None, classifier: Optional[DepartureArrivalClassifier] = None, ): \"\"\" Initialize the trip parser. Args: ner_extractor: NERExtractor instance. If None, creates a new one. classifier: DepartureArrivalClassifier instance. If None, creates a new one. \"\"\" self.ner_extractor = ner_extractor or NERExtractor() self.classifier = classifier or DepartureArrivalClassifier() def parse_trip(self, text: str) -> tuple[Optional[str], Optional[str]]: \"\"\" Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Args: text: Input text describing a trip in French. Returns: Tuple of (departure_city, arrival_city). Returns (None, None) if not enough cities are detected or classification fails. Raises: InvalidInputError: If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') \"\"\" # Validate input if not isinstance(text, str): raise InvalidInputError(\"text\", text, f\"Expected str, got {type(text).__name__}\") if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") # Limit text length for performance max_text_length = 1000 if len(text) > max_text_length: logger.warning(f\"Text too long ({len(text)} chars), truncating to {max_text_length}\") text = text[:max_text_length] try: # Step 1: Extract locations using NER cities = self.ner_extractor.extract_locations(text) if len(cities) < 2: logger.warning(f\"Not enough cities detected. Found: {cities}\") return (None, None) # Step 2: Use custom classifier to determine departure and arrival departure, arrival = self.classifier.classify_locations(text, cities) logger.debug(f\"Parsed trip: {departure} \u2192 {arrival}\") return (departure, arrival) except (InsufficientLocationsError, ClassificationError) as e: logger.warning(f\"Cannot parse trip: {e}\") return (None, None) except InvalidInputError: raise except Exception as e: logger.error(f\"Unexpected error parsing trip: {e}\", exc_info=True) return (None, None) __init__(ner_extractor: Optional[NERExtractor] = None, classifier: Optional[DepartureArrivalClassifier] = None) Initialize the trip parser. Parameters: Name Type Description Default ner_extractor Optional [ NERExtractor ] NERExtractor instance. If None, creates a new one. None classifier Optional [ DepartureArrivalClassifier ] DepartureArrivalClassifier instance. If None, creates a new one. None Source code in src/trip/trip_parser.py def __init__( self, ner_extractor: Optional[NERExtractor] = None, classifier: Optional[DepartureArrivalClassifier] = None, ): \"\"\" Initialize the trip parser. Args: ner_extractor: NERExtractor instance. If None, creates a new one. classifier: DepartureArrivalClassifier instance. If None, creates a new one. \"\"\" self.ner_extractor = ner_extractor or NERExtractor() self.classifier = classifier or DepartureArrivalClassifier() parse_trip(text: str) -> tuple[Optional[str], Optional[str]] Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Parameters: Name Type Description Default text str Input text describing a trip in French. required Returns: Type Description Optional [ str ] Tuple of (departure_city, arrival_city). Returns (None, None) if Optional [ str ] not enough cities are detected or classification fails. Raises: Type Description InvalidInputError If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') Source code in src/trip/trip_parser.py def parse_trip(self, text: str) -> tuple[Optional[str], Optional[str]]: \"\"\" Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Args: text: Input text describing a trip in French. Returns: Tuple of (departure_city, arrival_city). Returns (None, None) if not enough cities are detected or classification fails. Raises: InvalidInputError: If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') \"\"\" # Validate input if not isinstance(text, str): raise InvalidInputError(\"text\", text, f\"Expected str, got {type(text).__name__}\") if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") # Limit text length for performance max_text_length = 1000 if len(text) > max_text_length: logger.warning(f\"Text too long ({len(text)} chars), truncating to {max_text_length}\") text = text[:max_text_length] try: # Step 1: Extract locations using NER cities = self.ner_extractor.extract_locations(text) if len(cities) < 2: logger.warning(f\"Not enough cities detected. Found: {cities}\") return (None, None) # Step 2: Use custom classifier to determine departure and arrival departure, arrival = self.classifier.classify_locations(text, cities) logger.debug(f\"Parsed trip: {departure} \u2192 {arrival}\") return (departure, arrival) except (InsufficientLocationsError, ClassificationError) as e: logger.warning(f\"Cannot parse trip: {e}\") return (None, None) except InvalidInputError: raise except Exception as e: logger.error(f\"Unexpected error parsing trip: {e}\", exc_info=True) return (None, None) NERExtractor trip.models.ner.NERExtractor Bases: BaseModel Named Entity Recognition extractor for French text using CamemBERT. This class wraps the CamemBERT NER model to extract named entities, particularly locations, from French text. Note: This class only handles location extraction (NER). Classification of departure/arrival is handled by DepartureArrivalClassifier. Attributes: Name Type Description model_name Name of the Hugging Face model used for NER. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Je vais de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] Source code in src/trip/models/ner.py class NERExtractor(BaseModel): \"\"\" Named Entity Recognition extractor for French text using CamemBERT. This class wraps the CamemBERT NER model to extract named entities, particularly locations, from French text. Note: This class only handles location extraction (NER). Classification of departure/arrival is handled by DepartureArrivalClassifier. Attributes: model_name: Name of the Hugging Face model used for NER. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Je vais de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" def __init__(self, model_name: Optional[str] = None): \"\"\" Initialize the NER extractor with a pre-trained model. Args: model_name: Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). Raises: ModelLoadError: If the model cannot be loaded. InvalidInputError: If model_name is empty. \"\"\" super().__init__() config = get_config() self.model_name = model_name or config.model.ner_model_name if not self.model_name: raise InvalidInputError(\"model_name\", self.model_name, \"Model name cannot be empty\") self._pipeline = None self._load_model() def _load_model(self): \"\"\" Load the tokenizer, model, and create the NER pipeline. Raises: ModelLoadError: If model loading fails. \"\"\" try: logger.info(f\"Loading NER model: {self.model_name}\") # Load CamemBERT tokenizer directly to avoid fast tokenizer conversion issues tokenizer = CamembertTokenizer.from_pretrained(self.model_name) model = AutoModelForTokenClassification.from_pretrained(self.model_name) # Create the NER pipeline with explicitly loaded components self._pipeline = pipeline( \"ner\", model=model, tokenizer=tokenizer, aggregation_strategy=\"simple\" ) self._model = model self._tokenizer = tokenizer logger.info(\"NER model loaded successfully\") except Exception as e: logger.error(f\"Failed to load NER model: {e}\") raise ModelLoadError(self.model_name, e) def extract_entities(self, text: str) -> list[dict[str, any]]: \"\"\" Extract all named entities from the given text. Args: text: Input text in French. Returns: List of entities with their type, text, and confidence score. Each entity is a dict with keys: entity_group, word, score, start, end. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Input text cannot be empty\") try: entities = self._pipeline(text) logger.debug(f\"Extracted {len(entities)} entities from text\") return entities except Exception as e: logger.error(f\"Error during NER extraction: {e}\") raise def _split_compound_locations(self, location: str) -> list[str]: \"\"\" Split compound location strings into individual cities. Handles cases like \"Paris Marseille\" -> [\"Paris\", \"Marseille\"] Args: location: A location string that may contain multiple city names. Returns: List of individual city names. Examples: >>> extractor = NERExtractor() >>> extractor._split_compound_locations(\"Paris Marseille\") ['Paris', 'Marseille'] >>> extractor._split_compound_locations(\"New York\") ['New York'] \"\"\" # Split on whitespace words = location.split() # If we have multiple words that start with capital letters, # treat them as separate cities if len(words) > 1: # Check if all words start with capital letters (likely city names) if all(word and word[0].isupper() for word in words): return words return [location] def extract_locations(self, text: str) -> list[str]: \"\"\" Extract location entities (cities, places) from text. Args: text: Input text in French. Returns: List of location names found in the text, with compound locations split into individual cities. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" entities = self.extract_entities(text) locations = [] for ent in entities: if ent[\"entity_group\"] == \"LOC\": location = ent[\"word\"].strip() # Try to split compound locations (e.g., \"Paris Marseille\") split_locations = self._split_compound_locations(location) locations.extend(split_locations) logger.debug(f\"Found {len(locations)} locations: {locations}\") return locations __init__(model_name: Optional[str] = None) Initialize the NER extractor with a pre-trained model. Parameters: Name Type Description Default model_name Optional [ str ] Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). None Raises: Type Description ModelLoadError If the model cannot be loaded. InvalidInputError If model_name is empty. Source code in src/trip/models/ner.py def __init__(self, model_name: Optional[str] = None): \"\"\" Initialize the NER extractor with a pre-trained model. Args: model_name: Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). Raises: ModelLoadError: If the model cannot be loaded. InvalidInputError: If model_name is empty. \"\"\" super().__init__() config = get_config() self.model_name = model_name or config.model.ner_model_name if not self.model_name: raise InvalidInputError(\"model_name\", self.model_name, \"Model name cannot be empty\") self._pipeline = None self._load_model() extract_entities(text: str) -> list[dict[str, any]] Extract all named entities from the given text. Parameters: Name Type Description Default text str Input text in French. required Returns: Type Description list [ dict [ str , any ]] List of entities with their type, text, and confidence score. list [ dict [ str , any ]] Each entity is a dict with keys: entity_group, word, score, start, end. Raises: Type Description InvalidInputError If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] Source code in src/trip/models/ner.py def extract_entities(self, text: str) -> list[dict[str, any]]: \"\"\" Extract all named entities from the given text. Args: text: Input text in French. Returns: List of entities with their type, text, and confidence score. Each entity is a dict with keys: entity_group, word, score, start, end. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Input text cannot be empty\") try: entities = self._pipeline(text) logger.debug(f\"Extracted {len(entities)} entities from text\") return entities except Exception as e: logger.error(f\"Error during NER extraction: {e}\") raise extract_locations(text: str) -> list[str] Extract location entities (cities, places) from text. Parameters: Name Type Description Default text str Input text in French. required Returns: Type Description list [ str ] List of location names found in the text, with compound list [ str ] locations split into individual cities. Raises: Type Description InvalidInputError If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] Source code in src/trip/models/ner.py def extract_locations(self, text: str) -> list[str]: \"\"\" Extract location entities (cities, places) from text. Args: text: Input text in French. Returns: List of location names found in the text, with compound locations split into individual cities. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" entities = self.extract_entities(text) locations = [] for ent in entities: if ent[\"entity_group\"] == \"LOC\": location = ent[\"word\"].strip() # Try to split compound locations (e.g., \"Paris Marseille\") split_locations = self._split_compound_locations(location) locations.extend(split_locations) logger.debug(f\"Found {len(locations)} locations: {locations}\") return locations DepartureArrivalClassifier trip.models.classifier.DepartureArrivalClassifier Bases: BaseModel Custom classifier for identifying departure and arrival locations. This classifier uses a fine-tuned CamemBERT model trained specifically on travel sentence patterns to determine whether a location is a departure point or an arrival destination. The model is trained to classify locations marked with [LOC] tags in the context of the full sentence. Attributes: Name Type Description model_path Path to the fine-tuned model directory. device PyTorch device (cuda/cpu) used for inference. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 Source code in src/trip/models/classifier.py class DepartureArrivalClassifier(BaseModel): \"\"\" Custom classifier for identifying departure and arrival locations. This classifier uses a fine-tuned CamemBERT model trained specifically on travel sentence patterns to determine whether a location is a departure point or an arrival destination. The model is trained to classify locations marked with [LOC] tags in the context of the full sentence. Attributes: model_path: Path to the fine-tuned model directory. device: PyTorch device (cuda/cpu) used for inference. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 \"\"\" def __init__(self, model_path: Optional[str | Path] = None): \"\"\" Initialize the classifier. Args: model_path: Path to the fine-tuned model directory. If None, uses the default path from config. Raises: ModelNotFoundError: If the model directory doesn't exist. ModelLoadError: If the model cannot be loaded. \"\"\" super().__init__() config = get_config() # Use provided path or default from config if model_path is None: self.model_path = config.paths.departure_arrival_model else: self.model_path = Path(model_path) # Auto-detect device or use config device_name = config.model.device or (\"cuda\" if torch.cuda.is_available() else \"cpu\") self.device = torch.device(device_name) logger.info(f\"Using device: {self.device}\") self._load_model() def _load_model(self): \"\"\" Load the fine-tuned model and tokenizer. Raises: ModelNotFoundError: If model directory doesn't exist. ModelLoadError: If model loading fails. \"\"\" try: if not self.model_path.exists(): raise ModelNotFoundError(str(self.model_path)) logger.info(f\"Loading departure-arrival classifier from {self.model_path}\") self._tokenizer = CamembertTokenizer.from_pretrained(str(self.model_path)) self._model = CamembertForSequenceClassification.from_pretrained(str(self.model_path)) self._model.to(self.device) self._model.eval() logger.info(\"Departure-arrival classifier loaded successfully\") except ModelNotFoundError: raise except Exception as e: logger.error(f\"Failed to load classifier model: {e}\") raise ModelLoadError(str(self.model_path), e) def classify_location( self, text: str, location: str, confidence_threshold: Optional[float] = None ) -> tuple[str, float]: \"\"\" Classify whether a location is a departure or arrival point. Args: text: The full sentence context. location: The location to classify. confidence_threshold: Minimum confidence threshold (0-1). If None, uses value from config. Returns: Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: InvalidInputError: If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not location or not location.strip(): raise InvalidInputError(\"location\", location, \"Location cannot be empty\") # Use config threshold if not provided if confidence_threshold is None: config = get_config() confidence_threshold = config.model.confidence_threshold try: # Find location in text (case-insensitive) text_lower = text.lower() loc_lower = location.lower() loc_pos = text_lower.find(loc_lower) if loc_pos == -1: logger.warning(f\"Location '{location}' not found in text: {text}\") return (\"unknown\", 0.0) # Get actual location with correct casing from text loc_in_text = text[loc_pos : loc_pos + len(location)] # Create input text with location marker using special tokens marked_text = text.replace(loc_in_text, f\"[LOC] {loc_in_text} [/LOC]\", 1) # Get max_length from config config = get_config() max_length = config.training.max_length # Tokenize with max_length matching training config inputs = self._tokenizer( marked_text, max_length=max_length, padding=\"max_length\", truncation=True, return_tensors=\"pt\", ) # Move to device inputs = {k: v.to(self.device) for k, v in inputs.items()} # Predict with torch.no_grad(): outputs = self._model(**inputs) logits = outputs.logits probabilities = torch.softmax(logits, dim=-1) predicted_class = torch.argmax(probabilities, dim=-1).item() confidence = probabilities[0, predicted_class].item() # Map class to role role = \"departure\" if predicted_class == 0 else \"arrival\" # Check confidence threshold if confidence < confidence_threshold: logger.debug( f\"Low confidence ({confidence:.3f}) for '{location}', \" f\"marking as unknown\" ) return (\"unknown\", confidence) logger.debug( f\"Classified '{location}' as {role.upper()} \" f\"(confidence: {confidence:.3f})\" ) return (role, confidence) except Exception as e: logger.error(f\"Error classifying location '{location}': {e}\") return (\"unknown\", 0.0) def classify_locations( self, text: str, locations: list[str] ) -> tuple[Optional[str], Optional[str]]: \"\"\" Classify multiple locations and determine departure and arrival. Args: text: The full sentence context. locations: List of locations to classify. Returns: Tuple of (departure, arrival). Returns (None, None) if locations cannot be classified. Raises: InvalidInputError: If text is empty. InsufficientLocationsError: If fewer than 2 locations provided. ClassificationError: If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not locations or len(locations) < 2: raise InsufficientLocationsError( found_count=len(locations) if locations else 0, required_count=2 ) # Classify each location departure_candidates = [] arrival_candidates = [] for location in locations: try: role, confidence = self.classify_location(text, location) if role == \"departure\": departure_candidates.append((location, confidence)) elif role == \"arrival\": arrival_candidates.append((location, confidence)) except InvalidInputError as e: logger.warning(f\"Skipping invalid location: {e}\") continue # Select best candidates based on confidence departure = None arrival = None if departure_candidates: # Sort by confidence (highest first) departure_candidates.sort(key=lambda x: x[1], reverse=True) departure = departure_candidates[0][0] logger.debug( f\"Selected departure: {departure} \" f\"(confidence: {departure_candidates[0][1]:.3f})\" ) if arrival_candidates: # Sort by confidence (highest first) arrival_candidates.sort(key=lambda x: x[1], reverse=True) arrival = arrival_candidates[0][0] logger.debug( f\"Selected arrival: {arrival} \" f\"(confidence: {arrival_candidates[0][1]:.3f})\" ) # If we couldn't classify both departure and arrival, raise error if departure is None or arrival is None: logger.warning( f\"Classification failed for text: '{text}'. \" f\"Found {len(departure_candidates)} departure(s) and \" f\"{len(arrival_candidates)} arrival(s)\" ) raise ClassificationError(text, locations) return (departure, arrival) __init__(model_path: Optional[str | Path] = None) Initialize the classifier. Parameters: Name Type Description Default model_path Optional [ str | Path ] Path to the fine-tuned model directory. If None, uses the default path from config. None Raises: Type Description ModelNotFoundError If the model directory doesn't exist. ModelLoadError If the model cannot be loaded. Source code in src/trip/models/classifier.py def __init__(self, model_path: Optional[str | Path] = None): \"\"\" Initialize the classifier. Args: model_path: Path to the fine-tuned model directory. If None, uses the default path from config. Raises: ModelNotFoundError: If the model directory doesn't exist. ModelLoadError: If the model cannot be loaded. \"\"\" super().__init__() config = get_config() # Use provided path or default from config if model_path is None: self.model_path = config.paths.departure_arrival_model else: self.model_path = Path(model_path) # Auto-detect device or use config device_name = config.model.device or (\"cuda\" if torch.cuda.is_available() else \"cpu\") self.device = torch.device(device_name) logger.info(f\"Using device: {self.device}\") self._load_model() classify_location(text: str, location: str, confidence_threshold: Optional[float] = None) -> tuple[str, float] Classify whether a location is a departure or arrival point. Parameters: Name Type Description Default text str The full sentence context. required location str The location to classify. required confidence_threshold Optional [ float ] Minimum confidence threshold (0-1). If None, uses value from config. None Returns: Type Description tuple [ str , float ] Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: Type Description InvalidInputError If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 Source code in src/trip/models/classifier.py def classify_location( self, text: str, location: str, confidence_threshold: Optional[float] = None ) -> tuple[str, float]: \"\"\" Classify whether a location is a departure or arrival point. Args: text: The full sentence context. location: The location to classify. confidence_threshold: Minimum confidence threshold (0-1). If None, uses value from config. Returns: Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: InvalidInputError: If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not location or not location.strip(): raise InvalidInputError(\"location\", location, \"Location cannot be empty\") # Use config threshold if not provided if confidence_threshold is None: config = get_config() confidence_threshold = config.model.confidence_threshold try: # Find location in text (case-insensitive) text_lower = text.lower() loc_lower = location.lower() loc_pos = text_lower.find(loc_lower) if loc_pos == -1: logger.warning(f\"Location '{location}' not found in text: {text}\") return (\"unknown\", 0.0) # Get actual location with correct casing from text loc_in_text = text[loc_pos : loc_pos + len(location)] # Create input text with location marker using special tokens marked_text = text.replace(loc_in_text, f\"[LOC] {loc_in_text} [/LOC]\", 1) # Get max_length from config config = get_config() max_length = config.training.max_length # Tokenize with max_length matching training config inputs = self._tokenizer( marked_text, max_length=max_length, padding=\"max_length\", truncation=True, return_tensors=\"pt\", ) # Move to device inputs = {k: v.to(self.device) for k, v in inputs.items()} # Predict with torch.no_grad(): outputs = self._model(**inputs) logits = outputs.logits probabilities = torch.softmax(logits, dim=-1) predicted_class = torch.argmax(probabilities, dim=-1).item() confidence = probabilities[0, predicted_class].item() # Map class to role role = \"departure\" if predicted_class == 0 else \"arrival\" # Check confidence threshold if confidence < confidence_threshold: logger.debug( f\"Low confidence ({confidence:.3f}) for '{location}', \" f\"marking as unknown\" ) return (\"unknown\", confidence) logger.debug( f\"Classified '{location}' as {role.upper()} \" f\"(confidence: {confidence:.3f})\" ) return (role, confidence) except Exception as e: logger.error(f\"Error classifying location '{location}': {e}\") return (\"unknown\", 0.0) classify_locations(text: str, locations: list[str]) -> tuple[Optional[str], Optional[str]] Classify multiple locations and determine departure and arrival. Parameters: Name Type Description Default text str The full sentence context. required locations list [ str ] List of locations to classify. required Returns: Type Description Optional [ str ] Tuple of (departure, arrival). Returns (None, None) if Optional [ str ] locations cannot be classified. Raises: Type Description InvalidInputError If text is empty. InsufficientLocationsError If fewer than 2 locations provided. ClassificationError If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon Source code in src/trip/models/classifier.py def classify_locations( self, text: str, locations: list[str] ) -> tuple[Optional[str], Optional[str]]: \"\"\" Classify multiple locations and determine departure and arrival. Args: text: The full sentence context. locations: List of locations to classify. Returns: Tuple of (departure, arrival). Returns (None, None) if locations cannot be classified. Raises: InvalidInputError: If text is empty. InsufficientLocationsError: If fewer than 2 locations provided. ClassificationError: If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not locations or len(locations) < 2: raise InsufficientLocationsError( found_count=len(locations) if locations else 0, required_count=2 ) # Classify each location departure_candidates = [] arrival_candidates = [] for location in locations: try: role, confidence = self.classify_location(text, location) if role == \"departure\": departure_candidates.append((location, confidence)) elif role == \"arrival\": arrival_candidates.append((location, confidence)) except InvalidInputError as e: logger.warning(f\"Skipping invalid location: {e}\") continue # Select best candidates based on confidence departure = None arrival = None if departure_candidates: # Sort by confidence (highest first) departure_candidates.sort(key=lambda x: x[1], reverse=True) departure = departure_candidates[0][0] logger.debug( f\"Selected departure: {departure} \" f\"(confidence: {departure_candidates[0][1]:.3f})\" ) if arrival_candidates: # Sort by confidence (highest first) arrival_candidates.sort(key=lambda x: x[1], reverse=True) arrival = arrival_candidates[0][0] logger.debug( f\"Selected arrival: {arrival} \" f\"(confidence: {arrival_candidates[0][1]:.3f})\" ) # If we couldn't classify both departure and arrival, raise error if departure is None or arrival is None: logger.warning( f\"Classification failed for text: '{text}'. \" f\"Found {len(departure_candidates)} departure(s) and \" f\"{len(arrival_candidates)} arrival(s)\" ) raise ClassificationError(text, locations) return (departure, arrival) Exceptions TripExtractionError trip.exceptions.TripExtractionError Bases: Exception Base exception for all trip extraction errors. Source code in src/trip/exceptions.py class TripExtractionError(Exception): \"\"\"Base exception for all trip extraction errors.\"\"\" pass InvalidInputError trip.exceptions.InvalidInputError Bases: TripExtractionError Raised when input validation fails. Source code in src/trip/exceptions.py class InvalidInputError(TripExtractionError): \"\"\"Raised when input validation fails.\"\"\" def __init__(self, field: str, value, reason: str = \"\"): self.field = field self.value = value message = f\"Invalid input for '{field}'\" if reason: message += f\": {reason}\" super().__init__(message) InsufficientLocationsError trip.exceptions.InsufficientLocationsError Bases: TripExtractionError Raised when not enough locations are detected in the input text. Source code in src/trip/exceptions.py class InsufficientLocationsError(TripExtractionError): \"\"\"Raised when not enough locations are detected in the input text.\"\"\" def __init__(self, found_count: int, required_count: int = 2): self.found_count = found_count self.required_count = required_count super().__init__(f\"Need at least {required_count} locations, but only found {found_count}\") ModelNotFoundError trip.exceptions.ModelNotFoundError Bases: TripExtractionError Raised when a required model file cannot be found. Source code in src/trip/exceptions.py class ModelNotFoundError(TripExtractionError): \"\"\"Raised when a required model file cannot be found.\"\"\" def __init__(self, model_path: str, message: str = \"\"): self.model_path = model_path default_message = ( f\"Model not found at '{model_path}'. \" f\"Please train the model first by running: python scripts/train.py\" ) super().__init__(message or default_message) ClassificationError trip.exceptions.ClassificationError Bases: TripExtractionError Raised when location classification fails. Source code in src/trip/exceptions.py class ClassificationError(TripExtractionError): \"\"\"Raised when location classification fails.\"\"\" def __init__(self, text: str, locations: list): self.text = text self.locations = locations super().__init__( f\"Failed to classify locations in text. \" f\"Consider adding this pattern to the training dataset: '{text}'\" ) Configuration Config trip.config.Config dataclass Main configuration class that aggregates all settings. Source code in src/trip/config.py @dataclass class Config: \"\"\"Main configuration class that aggregates all settings.\"\"\" paths: Paths = field(default_factory=Paths) model: ModelConfig = field(default_factory=ModelConfig) training: TrainingConfig = field(default_factory=TrainingConfig) logging: LoggingConfig = field(default_factory=LoggingConfig) def __post_init__(self): \"\"\"Ensure required directories exist.\"\"\" self.paths.ensure_directories() __post_init__() Ensure required directories exist. Source code in src/trip/config.py def __post_init__(self): \"\"\"Ensure required directories exist.\"\"\" self.paths.ensure_directories() get_config trip.config.get_config() -> Config Get the global configuration instance. Returns: Type Description Config The global Config object. Source code in src/trip/config.py def get_config() -> Config: \"\"\" Get the global configuration instance. Returns: The global Config object. \"\"\" return config Exemples d'utilisation Exemple basique from trip import TripParser parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"{departure} \u2192 {arrival}\") Gestion d'erreurs from trip import TripParser from trip.exceptions import InvalidInputError, InsufficientLocationsError parser = TripParser() try: departure, arrival = parser.parse_trip(user_input) except InvalidInputError: print(\"Texte invalide\") except InsufficientLocationsError: print(\"Pas assez de villes\") Configuration personnalis\u00e9e from trip import get_config config = get_config() config.confidence_threshold = 0.8 Types de retour Les m\u00e9thodes principales retournent : M\u00e9thode Type de retour Description TripParser.parse_trip() tuple[str \\| None, str \\| None] (departure, arrival) NERExtractor.extract_locations() list[str] Liste des villes DepartureArrivalClassifier.classify_location() tuple[str, float] (role, confidence) Notes de version Cette documentation est g\u00e9n\u00e9r\u00e9e automatiquement depuis le code source avec mkdocstrings . Pour plus d'exemples, consultez le guide d'utilisation .","title":"API"},{"location":"api/#vue-densemble","text":"Trip Extraction expose trois composants principaux : TripParser : Point d'entr\u00e9e pour l'extraction de trajets NERExtractor : Extraction d'entit\u00e9s nomm\u00e9es (villes) DepartureArrivalClassifier : Classification d\u00e9part/arriv\u00e9e Exceptions : Gestion d'erreurs typ\u00e9es","title":"Vue d'ensemble"},{"location":"api/#tripparser","text":"","title":"TripParser"},{"location":"api/#trip.trip_parser.TripParser","text":"Parser for extracting trip information (departure and arrival) from text. Uses two specialized models: 1. NER model (CamemBERT) to identify locations (LOC entities) 2. Custom fine-tuned classifier to determine departure vs arrival This approach provides optimized, fast, and reliable trip extraction. Source code in src/trip/trip_parser.py class TripParser: \"\"\" Parser for extracting trip information (departure and arrival) from text. Uses two specialized models: 1. NER model (CamemBERT) to identify locations (LOC entities) 2. Custom fine-tuned classifier to determine departure vs arrival This approach provides optimized, fast, and reliable trip extraction. \"\"\" def __init__( self, ner_extractor: Optional[NERExtractor] = None, classifier: Optional[DepartureArrivalClassifier] = None, ): \"\"\" Initialize the trip parser. Args: ner_extractor: NERExtractor instance. If None, creates a new one. classifier: DepartureArrivalClassifier instance. If None, creates a new one. \"\"\" self.ner_extractor = ner_extractor or NERExtractor() self.classifier = classifier or DepartureArrivalClassifier() def parse_trip(self, text: str) -> tuple[Optional[str], Optional[str]]: \"\"\" Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Args: text: Input text describing a trip in French. Returns: Tuple of (departure_city, arrival_city). Returns (None, None) if not enough cities are detected or classification fails. Raises: InvalidInputError: If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') \"\"\" # Validate input if not isinstance(text, str): raise InvalidInputError(\"text\", text, f\"Expected str, got {type(text).__name__}\") if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") # Limit text length for performance max_text_length = 1000 if len(text) > max_text_length: logger.warning(f\"Text too long ({len(text)} chars), truncating to {max_text_length}\") text = text[:max_text_length] try: # Step 1: Extract locations using NER cities = self.ner_extractor.extract_locations(text) if len(cities) < 2: logger.warning(f\"Not enough cities detected. Found: {cities}\") return (None, None) # Step 2: Use custom classifier to determine departure and arrival departure, arrival = self.classifier.classify_locations(text, cities) logger.debug(f\"Parsed trip: {departure} \u2192 {arrival}\") return (departure, arrival) except (InsufficientLocationsError, ClassificationError) as e: logger.warning(f\"Cannot parse trip: {e}\") return (None, None) except InvalidInputError: raise except Exception as e: logger.error(f\"Unexpected error parsing trip: {e}\", exc_info=True) return (None, None)","title":"TripParser"},{"location":"api/#trip.trip_parser.TripParser.__init__","text":"Initialize the trip parser. Parameters: Name Type Description Default ner_extractor Optional [ NERExtractor ] NERExtractor instance. If None, creates a new one. None classifier Optional [ DepartureArrivalClassifier ] DepartureArrivalClassifier instance. If None, creates a new one. None Source code in src/trip/trip_parser.py def __init__( self, ner_extractor: Optional[NERExtractor] = None, classifier: Optional[DepartureArrivalClassifier] = None, ): \"\"\" Initialize the trip parser. Args: ner_extractor: NERExtractor instance. If None, creates a new one. classifier: DepartureArrivalClassifier instance. If None, creates a new one. \"\"\" self.ner_extractor = ner_extractor or NERExtractor() self.classifier = classifier or DepartureArrivalClassifier()","title":"__init__"},{"location":"api/#trip.trip_parser.TripParser.parse_trip","text":"Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Parameters: Name Type Description Default text str Input text describing a trip in French. required Returns: Type Description Optional [ str ] Tuple of (departure_city, arrival_city). Returns (None, None) if Optional [ str ] not enough cities are detected or classification fails. Raises: Type Description InvalidInputError If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') Source code in src/trip/trip_parser.py def parse_trip(self, text: str) -> tuple[Optional[str], Optional[str]]: \"\"\" Parse trip information from text to extract departure and arrival cities. Uses specialized ML models to: 1. Extract location names using CamemBERT NER 2. Classify each location's role using custom fine-tuned classifier This optimized approach provides fast and reliable results. Args: text: Input text describing a trip in French. Returns: Tuple of (departure_city, arrival_city). Returns (None, None) if not enough cities are detected or classification fails. Raises: InvalidInputError: If text is None or empty. Examples: >>> parser = TripParser() >>> parser.parse_trip(\"Train de Paris \u00e0 Lyon\") ('Paris', 'Lyon') >>> parser.parse_trip(\"Je veux aller \u00e0 Lille depuis Paris\") ('Paris', 'Lille') \"\"\" # Validate input if not isinstance(text, str): raise InvalidInputError(\"text\", text, f\"Expected str, got {type(text).__name__}\") if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") # Limit text length for performance max_text_length = 1000 if len(text) > max_text_length: logger.warning(f\"Text too long ({len(text)} chars), truncating to {max_text_length}\") text = text[:max_text_length] try: # Step 1: Extract locations using NER cities = self.ner_extractor.extract_locations(text) if len(cities) < 2: logger.warning(f\"Not enough cities detected. Found: {cities}\") return (None, None) # Step 2: Use custom classifier to determine departure and arrival departure, arrival = self.classifier.classify_locations(text, cities) logger.debug(f\"Parsed trip: {departure} \u2192 {arrival}\") return (departure, arrival) except (InsufficientLocationsError, ClassificationError) as e: logger.warning(f\"Cannot parse trip: {e}\") return (None, None) except InvalidInputError: raise except Exception as e: logger.error(f\"Unexpected error parsing trip: {e}\", exc_info=True) return (None, None)","title":"parse_trip"},{"location":"api/#nerextractor","text":"","title":"NERExtractor"},{"location":"api/#trip.models.ner.NERExtractor","text":"Bases: BaseModel Named Entity Recognition extractor for French text using CamemBERT. This class wraps the CamemBERT NER model to extract named entities, particularly locations, from French text. Note: This class only handles location extraction (NER). Classification of departure/arrival is handled by DepartureArrivalClassifier. Attributes: Name Type Description model_name Name of the Hugging Face model used for NER. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Je vais de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] Source code in src/trip/models/ner.py class NERExtractor(BaseModel): \"\"\" Named Entity Recognition extractor for French text using CamemBERT. This class wraps the CamemBERT NER model to extract named entities, particularly locations, from French text. Note: This class only handles location extraction (NER). Classification of departure/arrival is handled by DepartureArrivalClassifier. Attributes: model_name: Name of the Hugging Face model used for NER. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Je vais de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" def __init__(self, model_name: Optional[str] = None): \"\"\" Initialize the NER extractor with a pre-trained model. Args: model_name: Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). Raises: ModelLoadError: If the model cannot be loaded. InvalidInputError: If model_name is empty. \"\"\" super().__init__() config = get_config() self.model_name = model_name or config.model.ner_model_name if not self.model_name: raise InvalidInputError(\"model_name\", self.model_name, \"Model name cannot be empty\") self._pipeline = None self._load_model() def _load_model(self): \"\"\" Load the tokenizer, model, and create the NER pipeline. Raises: ModelLoadError: If model loading fails. \"\"\" try: logger.info(f\"Loading NER model: {self.model_name}\") # Load CamemBERT tokenizer directly to avoid fast tokenizer conversion issues tokenizer = CamembertTokenizer.from_pretrained(self.model_name) model = AutoModelForTokenClassification.from_pretrained(self.model_name) # Create the NER pipeline with explicitly loaded components self._pipeline = pipeline( \"ner\", model=model, tokenizer=tokenizer, aggregation_strategy=\"simple\" ) self._model = model self._tokenizer = tokenizer logger.info(\"NER model loaded successfully\") except Exception as e: logger.error(f\"Failed to load NER model: {e}\") raise ModelLoadError(self.model_name, e) def extract_entities(self, text: str) -> list[dict[str, any]]: \"\"\" Extract all named entities from the given text. Args: text: Input text in French. Returns: List of entities with their type, text, and confidence score. Each entity is a dict with keys: entity_group, word, score, start, end. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Input text cannot be empty\") try: entities = self._pipeline(text) logger.debug(f\"Extracted {len(entities)} entities from text\") return entities except Exception as e: logger.error(f\"Error during NER extraction: {e}\") raise def _split_compound_locations(self, location: str) -> list[str]: \"\"\" Split compound location strings into individual cities. Handles cases like \"Paris Marseille\" -> [\"Paris\", \"Marseille\"] Args: location: A location string that may contain multiple city names. Returns: List of individual city names. Examples: >>> extractor = NERExtractor() >>> extractor._split_compound_locations(\"Paris Marseille\") ['Paris', 'Marseille'] >>> extractor._split_compound_locations(\"New York\") ['New York'] \"\"\" # Split on whitespace words = location.split() # If we have multiple words that start with capital letters, # treat them as separate cities if len(words) > 1: # Check if all words start with capital letters (likely city names) if all(word and word[0].isupper() for word in words): return words return [location] def extract_locations(self, text: str) -> list[str]: \"\"\" Extract location entities (cities, places) from text. Args: text: Input text in French. Returns: List of location names found in the text, with compound locations split into individual cities. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" entities = self.extract_entities(text) locations = [] for ent in entities: if ent[\"entity_group\"] == \"LOC\": location = ent[\"word\"].strip() # Try to split compound locations (e.g., \"Paris Marseille\") split_locations = self._split_compound_locations(location) locations.extend(split_locations) logger.debug(f\"Found {len(locations)} locations: {locations}\") return locations","title":"NERExtractor"},{"location":"api/#trip.models.ner.NERExtractor.__init__","text":"Initialize the NER extractor with a pre-trained model. Parameters: Name Type Description Default model_name Optional [ str ] Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). None Raises: Type Description ModelLoadError If the model cannot be loaded. InvalidInputError If model_name is empty. Source code in src/trip/models/ner.py def __init__(self, model_name: Optional[str] = None): \"\"\" Initialize the NER extractor with a pre-trained model. Args: model_name: Name of the Hugging Face model to use for NER. Defaults to the value from config (Jean-Baptiste/camembert-ner). Raises: ModelLoadError: If the model cannot be loaded. InvalidInputError: If model_name is empty. \"\"\" super().__init__() config = get_config() self.model_name = model_name or config.model.ner_model_name if not self.model_name: raise InvalidInputError(\"model_name\", self.model_name, \"Model name cannot be empty\") self._pipeline = None self._load_model()","title":"__init__"},{"location":"api/#trip.models.ner.NERExtractor.extract_entities","text":"Extract all named entities from the given text. Parameters: Name Type Description Default text str Input text in French. required Returns: Type Description list [ dict [ str , any ]] List of entities with their type, text, and confidence score. list [ dict [ str , any ]] Each entity is a dict with keys: entity_group, word, score, start, end. Raises: Type Description InvalidInputError If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] Source code in src/trip/models/ner.py def extract_entities(self, text: str) -> list[dict[str, any]]: \"\"\" Extract all named entities from the given text. Args: text: Input text in French. Returns: List of entities with their type, text, and confidence score. Each entity is a dict with keys: entity_group, word, score, start, end. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> entities = extractor.extract_entities(\"Paris est en France\") >>> print(entities) [{'entity_group': 'LOC', 'word': 'Paris', 'score': 0.99, ...}, ...] \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Input text cannot be empty\") try: entities = self._pipeline(text) logger.debug(f\"Extracted {len(entities)} entities from text\") return entities except Exception as e: logger.error(f\"Error during NER extraction: {e}\") raise","title":"extract_entities"},{"location":"api/#trip.models.ner.NERExtractor.extract_locations","text":"Extract location entities (cities, places) from text. Parameters: Name Type Description Default text str Input text in French. required Returns: Type Description list [ str ] List of location names found in the text, with compound list [ str ] locations split into individual cities. Raises: Type Description InvalidInputError If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] Source code in src/trip/models/ner.py def extract_locations(self, text: str) -> list[str]: \"\"\" Extract location entities (cities, places) from text. Args: text: Input text in French. Returns: List of location names found in the text, with compound locations split into individual cities. Raises: InvalidInputError: If text is empty or None. Examples: >>> extractor = NERExtractor() >>> locations = extractor.extract_locations(\"Train de Paris \u00e0 Lyon\") >>> print(locations) ['Paris', 'Lyon'] \"\"\" entities = self.extract_entities(text) locations = [] for ent in entities: if ent[\"entity_group\"] == \"LOC\": location = ent[\"word\"].strip() # Try to split compound locations (e.g., \"Paris Marseille\") split_locations = self._split_compound_locations(location) locations.extend(split_locations) logger.debug(f\"Found {len(locations)} locations: {locations}\") return locations","title":"extract_locations"},{"location":"api/#departurearrivalclassifier","text":"","title":"DepartureArrivalClassifier"},{"location":"api/#trip.models.classifier.DepartureArrivalClassifier","text":"Bases: BaseModel Custom classifier for identifying departure and arrival locations. This classifier uses a fine-tuned CamemBERT model trained specifically on travel sentence patterns to determine whether a location is a departure point or an arrival destination. The model is trained to classify locations marked with [LOC] tags in the context of the full sentence. Attributes: Name Type Description model_path Path to the fine-tuned model directory. device PyTorch device (cuda/cpu) used for inference. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 Source code in src/trip/models/classifier.py class DepartureArrivalClassifier(BaseModel): \"\"\" Custom classifier for identifying departure and arrival locations. This classifier uses a fine-tuned CamemBERT model trained specifically on travel sentence patterns to determine whether a location is a departure point or an arrival destination. The model is trained to classify locations marked with [LOC] tags in the context of the full sentence. Attributes: model_path: Path to the fine-tuned model directory. device: PyTorch device (cuda/cpu) used for inference. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 \"\"\" def __init__(self, model_path: Optional[str | Path] = None): \"\"\" Initialize the classifier. Args: model_path: Path to the fine-tuned model directory. If None, uses the default path from config. Raises: ModelNotFoundError: If the model directory doesn't exist. ModelLoadError: If the model cannot be loaded. \"\"\" super().__init__() config = get_config() # Use provided path or default from config if model_path is None: self.model_path = config.paths.departure_arrival_model else: self.model_path = Path(model_path) # Auto-detect device or use config device_name = config.model.device or (\"cuda\" if torch.cuda.is_available() else \"cpu\") self.device = torch.device(device_name) logger.info(f\"Using device: {self.device}\") self._load_model() def _load_model(self): \"\"\" Load the fine-tuned model and tokenizer. Raises: ModelNotFoundError: If model directory doesn't exist. ModelLoadError: If model loading fails. \"\"\" try: if not self.model_path.exists(): raise ModelNotFoundError(str(self.model_path)) logger.info(f\"Loading departure-arrival classifier from {self.model_path}\") self._tokenizer = CamembertTokenizer.from_pretrained(str(self.model_path)) self._model = CamembertForSequenceClassification.from_pretrained(str(self.model_path)) self._model.to(self.device) self._model.eval() logger.info(\"Departure-arrival classifier loaded successfully\") except ModelNotFoundError: raise except Exception as e: logger.error(f\"Failed to load classifier model: {e}\") raise ModelLoadError(str(self.model_path), e) def classify_location( self, text: str, location: str, confidence_threshold: Optional[float] = None ) -> tuple[str, float]: \"\"\" Classify whether a location is a departure or arrival point. Args: text: The full sentence context. location: The location to classify. confidence_threshold: Minimum confidence threshold (0-1). If None, uses value from config. Returns: Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: InvalidInputError: If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not location or not location.strip(): raise InvalidInputError(\"location\", location, \"Location cannot be empty\") # Use config threshold if not provided if confidence_threshold is None: config = get_config() confidence_threshold = config.model.confidence_threshold try: # Find location in text (case-insensitive) text_lower = text.lower() loc_lower = location.lower() loc_pos = text_lower.find(loc_lower) if loc_pos == -1: logger.warning(f\"Location '{location}' not found in text: {text}\") return (\"unknown\", 0.0) # Get actual location with correct casing from text loc_in_text = text[loc_pos : loc_pos + len(location)] # Create input text with location marker using special tokens marked_text = text.replace(loc_in_text, f\"[LOC] {loc_in_text} [/LOC]\", 1) # Get max_length from config config = get_config() max_length = config.training.max_length # Tokenize with max_length matching training config inputs = self._tokenizer( marked_text, max_length=max_length, padding=\"max_length\", truncation=True, return_tensors=\"pt\", ) # Move to device inputs = {k: v.to(self.device) for k, v in inputs.items()} # Predict with torch.no_grad(): outputs = self._model(**inputs) logits = outputs.logits probabilities = torch.softmax(logits, dim=-1) predicted_class = torch.argmax(probabilities, dim=-1).item() confidence = probabilities[0, predicted_class].item() # Map class to role role = \"departure\" if predicted_class == 0 else \"arrival\" # Check confidence threshold if confidence < confidence_threshold: logger.debug( f\"Low confidence ({confidence:.3f}) for '{location}', \" f\"marking as unknown\" ) return (\"unknown\", confidence) logger.debug( f\"Classified '{location}' as {role.upper()} \" f\"(confidence: {confidence:.3f})\" ) return (role, confidence) except Exception as e: logger.error(f\"Error classifying location '{location}': {e}\") return (\"unknown\", 0.0) def classify_locations( self, text: str, locations: list[str] ) -> tuple[Optional[str], Optional[str]]: \"\"\" Classify multiple locations and determine departure and arrival. Args: text: The full sentence context. locations: List of locations to classify. Returns: Tuple of (departure, arrival). Returns (None, None) if locations cannot be classified. Raises: InvalidInputError: If text is empty. InsufficientLocationsError: If fewer than 2 locations provided. ClassificationError: If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not locations or len(locations) < 2: raise InsufficientLocationsError( found_count=len(locations) if locations else 0, required_count=2 ) # Classify each location departure_candidates = [] arrival_candidates = [] for location in locations: try: role, confidence = self.classify_location(text, location) if role == \"departure\": departure_candidates.append((location, confidence)) elif role == \"arrival\": arrival_candidates.append((location, confidence)) except InvalidInputError as e: logger.warning(f\"Skipping invalid location: {e}\") continue # Select best candidates based on confidence departure = None arrival = None if departure_candidates: # Sort by confidence (highest first) departure_candidates.sort(key=lambda x: x[1], reverse=True) departure = departure_candidates[0][0] logger.debug( f\"Selected departure: {departure} \" f\"(confidence: {departure_candidates[0][1]:.3f})\" ) if arrival_candidates: # Sort by confidence (highest first) arrival_candidates.sort(key=lambda x: x[1], reverse=True) arrival = arrival_candidates[0][0] logger.debug( f\"Selected arrival: {arrival} \" f\"(confidence: {arrival_candidates[0][1]:.3f})\" ) # If we couldn't classify both departure and arrival, raise error if departure is None or arrival is None: logger.warning( f\"Classification failed for text: '{text}'. \" f\"Found {len(departure_candidates)} departure(s) and \" f\"{len(arrival_candidates)} arrival(s)\" ) raise ClassificationError(text, locations) return (departure, arrival)","title":"DepartureArrivalClassifier"},{"location":"api/#trip.models.classifier.DepartureArrivalClassifier.__init__","text":"Initialize the classifier. Parameters: Name Type Description Default model_path Optional [ str | Path ] Path to the fine-tuned model directory. If None, uses the default path from config. None Raises: Type Description ModelNotFoundError If the model directory doesn't exist. ModelLoadError If the model cannot be loaded. Source code in src/trip/models/classifier.py def __init__(self, model_path: Optional[str | Path] = None): \"\"\" Initialize the classifier. Args: model_path: Path to the fine-tuned model directory. If None, uses the default path from config. Raises: ModelNotFoundError: If the model directory doesn't exist. ModelLoadError: If the model cannot be loaded. \"\"\" super().__init__() config = get_config() # Use provided path or default from config if model_path is None: self.model_path = config.paths.departure_arrival_model else: self.model_path = Path(model_path) # Auto-detect device or use config device_name = config.model.device or (\"cuda\" if torch.cuda.is_available() else \"cpu\") self.device = torch.device(device_name) logger.info(f\"Using device: {self.device}\") self._load_model()","title":"__init__"},{"location":"api/#trip.models.classifier.DepartureArrivalClassifier.classify_location","text":"Classify whether a location is a departure or arrival point. Parameters: Name Type Description Default text str The full sentence context. required location str The location to classify. required confidence_threshold Optional [ float ] Minimum confidence threshold (0-1). If None, uses value from config. None Returns: Type Description tuple [ str , float ] Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: Type Description InvalidInputError If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 Source code in src/trip/models/classifier.py def classify_location( self, text: str, location: str, confidence_threshold: Optional[float] = None ) -> tuple[str, float]: \"\"\" Classify whether a location is a departure or arrival point. Args: text: The full sentence context. location: The location to classify. confidence_threshold: Minimum confidence threshold (0-1). If None, uses value from config. Returns: Tuple of (role, confidence) where: - role is 'departure', 'arrival', or 'unknown' - confidence is a float between 0 and 1 Raises: InvalidInputError: If text or location is empty. Examples: >>> classifier = DepartureArrivalClassifier() >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Paris\") >>> print(f\"{role}: {conf:.2f}\") departure: 0.98 >>> role, conf = classifier.classify_location(\"Je vais de Paris \u00e0 Lyon\", \"Lyon\") >>> print(f\"{role}: {conf:.2f}\") arrival: 0.97 \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not location or not location.strip(): raise InvalidInputError(\"location\", location, \"Location cannot be empty\") # Use config threshold if not provided if confidence_threshold is None: config = get_config() confidence_threshold = config.model.confidence_threshold try: # Find location in text (case-insensitive) text_lower = text.lower() loc_lower = location.lower() loc_pos = text_lower.find(loc_lower) if loc_pos == -1: logger.warning(f\"Location '{location}' not found in text: {text}\") return (\"unknown\", 0.0) # Get actual location with correct casing from text loc_in_text = text[loc_pos : loc_pos + len(location)] # Create input text with location marker using special tokens marked_text = text.replace(loc_in_text, f\"[LOC] {loc_in_text} [/LOC]\", 1) # Get max_length from config config = get_config() max_length = config.training.max_length # Tokenize with max_length matching training config inputs = self._tokenizer( marked_text, max_length=max_length, padding=\"max_length\", truncation=True, return_tensors=\"pt\", ) # Move to device inputs = {k: v.to(self.device) for k, v in inputs.items()} # Predict with torch.no_grad(): outputs = self._model(**inputs) logits = outputs.logits probabilities = torch.softmax(logits, dim=-1) predicted_class = torch.argmax(probabilities, dim=-1).item() confidence = probabilities[0, predicted_class].item() # Map class to role role = \"departure\" if predicted_class == 0 else \"arrival\" # Check confidence threshold if confidence < confidence_threshold: logger.debug( f\"Low confidence ({confidence:.3f}) for '{location}', \" f\"marking as unknown\" ) return (\"unknown\", confidence) logger.debug( f\"Classified '{location}' as {role.upper()} \" f\"(confidence: {confidence:.3f})\" ) return (role, confidence) except Exception as e: logger.error(f\"Error classifying location '{location}': {e}\") return (\"unknown\", 0.0)","title":"classify_location"},{"location":"api/#trip.models.classifier.DepartureArrivalClassifier.classify_locations","text":"Classify multiple locations and determine departure and arrival. Parameters: Name Type Description Default text str The full sentence context. required locations list [ str ] List of locations to classify. required Returns: Type Description Optional [ str ] Tuple of (departure, arrival). Returns (None, None) if Optional [ str ] locations cannot be classified. Raises: Type Description InvalidInputError If text is empty. InsufficientLocationsError If fewer than 2 locations provided. ClassificationError If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon Source code in src/trip/models/classifier.py def classify_locations( self, text: str, locations: list[str] ) -> tuple[Optional[str], Optional[str]]: \"\"\" Classify multiple locations and determine departure and arrival. Args: text: The full sentence context. locations: List of locations to classify. Returns: Tuple of (departure, arrival). Returns (None, None) if locations cannot be classified. Raises: InvalidInputError: If text is empty. InsufficientLocationsError: If fewer than 2 locations provided. ClassificationError: If classification fails and pattern should be added to training. Examples: >>> classifier = DepartureArrivalClassifier() >>> departure, arrival = classifier.classify_locations( ... \"Train de Paris \u00e0 Lyon\", ... [\"Paris\", \"Lyon\"] ... ) >>> print(f\"{departure} \u2192 {arrival}\") Paris \u2192 Lyon \"\"\" if not text or not text.strip(): raise InvalidInputError(\"text\", text, \"Text cannot be empty\") if not locations or len(locations) < 2: raise InsufficientLocationsError( found_count=len(locations) if locations else 0, required_count=2 ) # Classify each location departure_candidates = [] arrival_candidates = [] for location in locations: try: role, confidence = self.classify_location(text, location) if role == \"departure\": departure_candidates.append((location, confidence)) elif role == \"arrival\": arrival_candidates.append((location, confidence)) except InvalidInputError as e: logger.warning(f\"Skipping invalid location: {e}\") continue # Select best candidates based on confidence departure = None arrival = None if departure_candidates: # Sort by confidence (highest first) departure_candidates.sort(key=lambda x: x[1], reverse=True) departure = departure_candidates[0][0] logger.debug( f\"Selected departure: {departure} \" f\"(confidence: {departure_candidates[0][1]:.3f})\" ) if arrival_candidates: # Sort by confidence (highest first) arrival_candidates.sort(key=lambda x: x[1], reverse=True) arrival = arrival_candidates[0][0] logger.debug( f\"Selected arrival: {arrival} \" f\"(confidence: {arrival_candidates[0][1]:.3f})\" ) # If we couldn't classify both departure and arrival, raise error if departure is None or arrival is None: logger.warning( f\"Classification failed for text: '{text}'. \" f\"Found {len(departure_candidates)} departure(s) and \" f\"{len(arrival_candidates)} arrival(s)\" ) raise ClassificationError(text, locations) return (departure, arrival)","title":"classify_locations"},{"location":"api/#exceptions","text":"","title":"Exceptions"},{"location":"api/#tripextractionerror","text":"","title":"TripExtractionError"},{"location":"api/#trip.exceptions.TripExtractionError","text":"Bases: Exception Base exception for all trip extraction errors. Source code in src/trip/exceptions.py class TripExtractionError(Exception): \"\"\"Base exception for all trip extraction errors.\"\"\" pass","title":"TripExtractionError"},{"location":"api/#invalidinputerror","text":"","title":"InvalidInputError"},{"location":"api/#trip.exceptions.InvalidInputError","text":"Bases: TripExtractionError Raised when input validation fails. Source code in src/trip/exceptions.py class InvalidInputError(TripExtractionError): \"\"\"Raised when input validation fails.\"\"\" def __init__(self, field: str, value, reason: str = \"\"): self.field = field self.value = value message = f\"Invalid input for '{field}'\" if reason: message += f\": {reason}\" super().__init__(message)","title":"InvalidInputError"},{"location":"api/#insufficientlocationserror","text":"","title":"InsufficientLocationsError"},{"location":"api/#trip.exceptions.InsufficientLocationsError","text":"Bases: TripExtractionError Raised when not enough locations are detected in the input text. Source code in src/trip/exceptions.py class InsufficientLocationsError(TripExtractionError): \"\"\"Raised when not enough locations are detected in the input text.\"\"\" def __init__(self, found_count: int, required_count: int = 2): self.found_count = found_count self.required_count = required_count super().__init__(f\"Need at least {required_count} locations, but only found {found_count}\")","title":"InsufficientLocationsError"},{"location":"api/#modelnotfounderror","text":"","title":"ModelNotFoundError"},{"location":"api/#trip.exceptions.ModelNotFoundError","text":"Bases: TripExtractionError Raised when a required model file cannot be found. Source code in src/trip/exceptions.py class ModelNotFoundError(TripExtractionError): \"\"\"Raised when a required model file cannot be found.\"\"\" def __init__(self, model_path: str, message: str = \"\"): self.model_path = model_path default_message = ( f\"Model not found at '{model_path}'. \" f\"Please train the model first by running: python scripts/train.py\" ) super().__init__(message or default_message)","title":"ModelNotFoundError"},{"location":"api/#classificationerror","text":"","title":"ClassificationError"},{"location":"api/#trip.exceptions.ClassificationError","text":"Bases: TripExtractionError Raised when location classification fails. Source code in src/trip/exceptions.py class ClassificationError(TripExtractionError): \"\"\"Raised when location classification fails.\"\"\" def __init__(self, text: str, locations: list): self.text = text self.locations = locations super().__init__( f\"Failed to classify locations in text. \" f\"Consider adding this pattern to the training dataset: '{text}'\" )","title":"ClassificationError"},{"location":"api/#configuration","text":"","title":"Configuration"},{"location":"api/#config","text":"","title":"Config"},{"location":"api/#trip.config.Config","text":"Main configuration class that aggregates all settings. Source code in src/trip/config.py @dataclass class Config: \"\"\"Main configuration class that aggregates all settings.\"\"\" paths: Paths = field(default_factory=Paths) model: ModelConfig = field(default_factory=ModelConfig) training: TrainingConfig = field(default_factory=TrainingConfig) logging: LoggingConfig = field(default_factory=LoggingConfig) def __post_init__(self): \"\"\"Ensure required directories exist.\"\"\" self.paths.ensure_directories()","title":"Config"},{"location":"api/#trip.config.Config.__post_init__","text":"Ensure required directories exist. Source code in src/trip/config.py def __post_init__(self): \"\"\"Ensure required directories exist.\"\"\" self.paths.ensure_directories()","title":"__post_init__"},{"location":"api/#get_config","text":"","title":"get_config"},{"location":"api/#trip.config.get_config","text":"Get the global configuration instance. Returns: Type Description Config The global Config object. Source code in src/trip/config.py def get_config() -> Config: \"\"\" Get the global configuration instance. Returns: The global Config object. \"\"\" return config","title":"get_config"},{"location":"api/#exemples-dutilisation","text":"","title":"Exemples d'utilisation"},{"location":"api/#exemple-basique","text":"from trip import TripParser parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"{departure} \u2192 {arrival}\")","title":"Exemple basique"},{"location":"api/#gestion-derreurs","text":"from trip import TripParser from trip.exceptions import InvalidInputError, InsufficientLocationsError parser = TripParser() try: departure, arrival = parser.parse_trip(user_input) except InvalidInputError: print(\"Texte invalide\") except InsufficientLocationsError: print(\"Pas assez de villes\")","title":"Gestion d'erreurs"},{"location":"api/#configuration-personnalisee","text":"from trip import get_config config = get_config() config.confidence_threshold = 0.8","title":"Configuration personnalis\u00e9e"},{"location":"api/#types-de-retour","text":"Les m\u00e9thodes principales retournent : M\u00e9thode Type de retour Description TripParser.parse_trip() tuple[str \\| None, str \\| None] (departure, arrival) NERExtractor.extract_locations() list[str] Liste des villes DepartureArrivalClassifier.classify_location() tuple[str, float] (role, confidence)","title":"Types de retour"},{"location":"api/#notes-de-version","text":"Cette documentation est g\u00e9n\u00e9r\u00e9e automatiquement depuis le code source avec mkdocstrings . Pour plus d'exemples, consultez le guide d'utilisation .","title":"Notes de version"},{"location":"architecture/","text":"Vue d'ensemble Le syst\u00e8me Trip Extraction utilise deux mod\u00e8les de NLP pour extraire les trajets : Input: \"Je vais de Paris \u00e0 Lyon\" \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 NER Extractor \u2502 \u2192 D\u00e9tecte les villes: [\"Paris\", \"Lyon\"] \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Classifier \u2502 \u2192 Paris: departure (98%) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2192 Lyon: arrival (97%) \u2193 Output: (Paris, Lyon) Composants principaux 1. TripParser Point d'entr\u00e9e principal de l'API. from trip import TripParser parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") Responsabilit\u00e9s : - Orchestration des composants - Validation de l'entr\u00e9e - Gestion des erreurs Fichier : src/trip/trip_parser.py 2. NERExtractor Extraction d'entit\u00e9s nomm\u00e9es (villes) avec CamemBERT. from trip.ner_extractor import NERExtractor ner = NERExtractor() locations = ner.extract_locations(\"Je vais de Paris \u00e0 Lyon\") # \u2192 ['Paris', 'Lyon'] Mod\u00e8le : camembert-ner (Jean-Baptiste/camembert-ner) Responsabilit\u00e9s : - D\u00e9tection des entit\u00e9s LOC (locations) - Filtrage et nettoyage - Gestion des entit\u00e9s multi-tokens Fichier : src/trip/ner_extractor.py 3. DepartureArrivalClassifier Classification d\u00e9part vs arriv\u00e9e avec CamemBERT fine-tun\u00e9. from trip.departure_arrival_classifier import DepartureArrivalClassifier classifier = DepartureArrivalClassifier() role, confidence = classifier.classify_location( \"Je vais de Paris \u00e0 Lyon\", \"Paris\" ) # \u2192 ('departure', 0.98) Mod\u00e8le : CamemBERT fine-tun\u00e9 sur dataset custom Responsabilit\u00e9s : - Classification binaire (d\u00e9part/arriv\u00e9e) - Score de confiance - Gestion du contexte Fichier : src/trip/departure_arrival_classifier.py Pipeline de traitement \u00c9tape 1 : Extraction NER text = \"Je vais de Paris \u00e0 Lyon\" locations = ner.extract_locations(text) # \u2192 ['Paris', 'Lyon'] Le NER extractor : 1. Tokenize le texte avec CamemBERT tokenizer 2. Passe les tokens dans le mod\u00e8le CamemBERT-NER 3. D\u00e9tecte les entit\u00e9s B-LOC et I-LOC 4. Reconstruit les villes compl\u00e8tes 5. Filtre et nettoie les r\u00e9sultats \u00c9tape 2 : Classification for location in locations: role, confidence = classifier.classify_location(text, location) Le classifier : 1. Ajoute les tokens [LOC] et [/LOC] autour de la ville 2. Tokenize : \"Je vais de [LOC] Paris [/LOC] \u00e0 Lyon\" 3. Passe dans le mod\u00e8le CamemBERT fine-tun\u00e9 4. Obtient un score de confiance pour d\u00e9part/arriv\u00e9e 5. Retourne le r\u00f4le et la confiance \u00c9tape 3 : Validation if len(locations) < 2: raise InsufficientLocationsError() if confidence < threshold: raise LowConfidenceError() V\u00e9rifications : - Au moins 2 villes d\u00e9tect\u00e9es - Confiance suffisante (> 0.5 par d\u00e9faut) - Pas de doublons Format du dataset d'entra\u00eenement Le classifier est entra\u00een\u00e9 sur ce format : [ { \"text\": \"Je vais de [LOC]Paris[/LOC] \u00e0 Lyon\", \"label\": 0 }, { \"text\": \"Je vais de Paris \u00e0 [LOC]Lyon[/LOC]\", \"label\": 1 } ] label: 0 = d\u00e9part label: 1 = arriv\u00e9e [LOC] et [/LOC] marquent la ville \u00e0 classifier Fichier : data/training_dataset.json Gestion des erreurs from trip.exceptions import ( TripExtractionError, # Classe de base InvalidInputError, # Entr\u00e9e vide/invalide InsufficientLocationsError,# Moins de 2 villes LowConfidenceError # Confiance trop faible ) Hi\u00e9rarchie : TripExtractionError \u251c\u2500\u2500 InvalidInputError \u251c\u2500\u2500 InsufficientLocationsError \u2514\u2500\u2500 LowConfidenceError Configuration from trip.config import get_config config = get_config() print(config.model.ner_model_name) # camembert-ner print(config.model.classifier_model_path) # models/departure_arrival_classifier print(config.model.device) # cuda ou cpu print(config.model.confidence_threshold) # 0.5 Fichier : src/trip/utils.py Performance NER Extraction M\u00e9trique Score Precision 95% Recall 93% F1-Score 94% Classifier M\u00e9trique Score Accuracy 96% Precision 97% Recall 96% F1-Score 98% Temps d'ex\u00e9cution Device Temps par phrase CPU 0.3-0.5s GPU (CUDA) 0.1-0.2s Structure du projet bootstrap/ \u251c\u2500\u2500 src/trip/ \u2502 \u251c\u2500\u2500 __init__.py # Exports publics \u2502 \u251c\u2500\u2500 __main__.py # Point d'entr\u00e9e CLI \u2502 \u251c\u2500\u2500 trip_parser.py # TripParser principal \u2502 \u251c\u2500\u2500 ner_extractor.py # NERExtractor \u2502 \u251c\u2500\u2500 departure_arrival_classifier.py # Classifier \u2502 \u2514\u2500\u2500 utils.py # Config, logging, exceptions \u251c\u2500\u2500 data/ \u2502 \u2514\u2500\u2500 training_dataset.json # Dataset d'entra\u00eenement \u251c\u2500\u2500 models/ \u2502 \u2514\u2500\u2500 departure_arrival_classifier/ # Mod\u00e8le entra\u00een\u00e9 \u251c\u2500\u2500 train_model.py # Script d'entra\u00eenement \u2514\u2500\u2500 pyproject.toml # Configuration du projet Entra\u00eenement trip-train Le script : 1. Charge data/training_dataset.json 2. Split train/test (80/20) 3. Fine-tune CamemBERT (3 epochs) 4. \u00c9value sur le test set 5. Sauvegarde dans models/departure_arrival_classifier/ Dur\u00e9e : 2-3 min (GPU) ou 10-12 min (CPU) Fichier : train_model.py","title":"Architecture"},{"location":"architecture/#vue-densemble","text":"Le syst\u00e8me Trip Extraction utilise deux mod\u00e8les de NLP pour extraire les trajets : Input: \"Je vais de Paris \u00e0 Lyon\" \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 NER Extractor \u2502 \u2192 D\u00e9tecte les villes: [\"Paris\", \"Lyon\"] \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Classifier \u2502 \u2192 Paris: departure (98%) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2192 Lyon: arrival (97%) \u2193 Output: (Paris, Lyon)","title":"Vue d'ensemble"},{"location":"architecture/#composants-principaux","text":"","title":"Composants principaux"},{"location":"architecture/#1-tripparser","text":"Point d'entr\u00e9e principal de l'API. from trip import TripParser parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") Responsabilit\u00e9s : - Orchestration des composants - Validation de l'entr\u00e9e - Gestion des erreurs Fichier : src/trip/trip_parser.py","title":"1. TripParser"},{"location":"architecture/#2-nerextractor","text":"Extraction d'entit\u00e9s nomm\u00e9es (villes) avec CamemBERT. from trip.ner_extractor import NERExtractor ner = NERExtractor() locations = ner.extract_locations(\"Je vais de Paris \u00e0 Lyon\") # \u2192 ['Paris', 'Lyon'] Mod\u00e8le : camembert-ner (Jean-Baptiste/camembert-ner) Responsabilit\u00e9s : - D\u00e9tection des entit\u00e9s LOC (locations) - Filtrage et nettoyage - Gestion des entit\u00e9s multi-tokens Fichier : src/trip/ner_extractor.py","title":"2. NERExtractor"},{"location":"architecture/#3-departurearrivalclassifier","text":"Classification d\u00e9part vs arriv\u00e9e avec CamemBERT fine-tun\u00e9. from trip.departure_arrival_classifier import DepartureArrivalClassifier classifier = DepartureArrivalClassifier() role, confidence = classifier.classify_location( \"Je vais de Paris \u00e0 Lyon\", \"Paris\" ) # \u2192 ('departure', 0.98) Mod\u00e8le : CamemBERT fine-tun\u00e9 sur dataset custom Responsabilit\u00e9s : - Classification binaire (d\u00e9part/arriv\u00e9e) - Score de confiance - Gestion du contexte Fichier : src/trip/departure_arrival_classifier.py","title":"3. DepartureArrivalClassifier"},{"location":"architecture/#pipeline-de-traitement","text":"","title":"Pipeline de traitement"},{"location":"architecture/#etape-1-extraction-ner","text":"text = \"Je vais de Paris \u00e0 Lyon\" locations = ner.extract_locations(text) # \u2192 ['Paris', 'Lyon'] Le NER extractor : 1. Tokenize le texte avec CamemBERT tokenizer 2. Passe les tokens dans le mod\u00e8le CamemBERT-NER 3. D\u00e9tecte les entit\u00e9s B-LOC et I-LOC 4. Reconstruit les villes compl\u00e8tes 5. Filtre et nettoie les r\u00e9sultats","title":"\u00c9tape 1 : Extraction NER"},{"location":"architecture/#etape-2-classification","text":"for location in locations: role, confidence = classifier.classify_location(text, location) Le classifier : 1. Ajoute les tokens [LOC] et [/LOC] autour de la ville 2. Tokenize : \"Je vais de [LOC] Paris [/LOC] \u00e0 Lyon\" 3. Passe dans le mod\u00e8le CamemBERT fine-tun\u00e9 4. Obtient un score de confiance pour d\u00e9part/arriv\u00e9e 5. Retourne le r\u00f4le et la confiance","title":"\u00c9tape 2 : Classification"},{"location":"architecture/#etape-3-validation","text":"if len(locations) < 2: raise InsufficientLocationsError() if confidence < threshold: raise LowConfidenceError() V\u00e9rifications : - Au moins 2 villes d\u00e9tect\u00e9es - Confiance suffisante (> 0.5 par d\u00e9faut) - Pas de doublons","title":"\u00c9tape 3 : Validation"},{"location":"architecture/#format-du-dataset-dentrainement","text":"Le classifier est entra\u00een\u00e9 sur ce format : [ { \"text\": \"Je vais de [LOC]Paris[/LOC] \u00e0 Lyon\", \"label\": 0 }, { \"text\": \"Je vais de Paris \u00e0 [LOC]Lyon[/LOC]\", \"label\": 1 } ] label: 0 = d\u00e9part label: 1 = arriv\u00e9e [LOC] et [/LOC] marquent la ville \u00e0 classifier Fichier : data/training_dataset.json","title":"Format du dataset d'entra\u00eenement"},{"location":"architecture/#gestion-des-erreurs","text":"from trip.exceptions import ( TripExtractionError, # Classe de base InvalidInputError, # Entr\u00e9e vide/invalide InsufficientLocationsError,# Moins de 2 villes LowConfidenceError # Confiance trop faible ) Hi\u00e9rarchie : TripExtractionError \u251c\u2500\u2500 InvalidInputError \u251c\u2500\u2500 InsufficientLocationsError \u2514\u2500\u2500 LowConfidenceError","title":"Gestion des erreurs"},{"location":"architecture/#configuration","text":"from trip.config import get_config config = get_config() print(config.model.ner_model_name) # camembert-ner print(config.model.classifier_model_path) # models/departure_arrival_classifier print(config.model.device) # cuda ou cpu print(config.model.confidence_threshold) # 0.5 Fichier : src/trip/utils.py","title":"Configuration"},{"location":"architecture/#performance","text":"","title":"Performance"},{"location":"architecture/#ner-extraction","text":"M\u00e9trique Score Precision 95% Recall 93% F1-Score 94%","title":"NER Extraction"},{"location":"architecture/#classifier","text":"M\u00e9trique Score Accuracy 96% Precision 97% Recall 96% F1-Score 98%","title":"Classifier"},{"location":"architecture/#temps-dexecution","text":"Device Temps par phrase CPU 0.3-0.5s GPU (CUDA) 0.1-0.2s","title":"Temps d'ex\u00e9cution"},{"location":"architecture/#structure-du-projet","text":"bootstrap/ \u251c\u2500\u2500 src/trip/ \u2502 \u251c\u2500\u2500 __init__.py # Exports publics \u2502 \u251c\u2500\u2500 __main__.py # Point d'entr\u00e9e CLI \u2502 \u251c\u2500\u2500 trip_parser.py # TripParser principal \u2502 \u251c\u2500\u2500 ner_extractor.py # NERExtractor \u2502 \u251c\u2500\u2500 departure_arrival_classifier.py # Classifier \u2502 \u2514\u2500\u2500 utils.py # Config, logging, exceptions \u251c\u2500\u2500 data/ \u2502 \u2514\u2500\u2500 training_dataset.json # Dataset d'entra\u00eenement \u251c\u2500\u2500 models/ \u2502 \u2514\u2500\u2500 departure_arrival_classifier/ # Mod\u00e8le entra\u00een\u00e9 \u251c\u2500\u2500 train_model.py # Script d'entra\u00eenement \u2514\u2500\u2500 pyproject.toml # Configuration du projet","title":"Structure du projet"},{"location":"architecture/#entrainement","text":"trip-train Le script : 1. Charge data/training_dataset.json 2. Split train/test (80/20) 3. Fine-tune CamemBERT (3 epochs) 4. \u00c9value sur le test set 5. Sauvegarde dans models/departure_arrival_classifier/ Dur\u00e9e : 2-3 min (GPU) ou 10-12 min (CPU) Fichier : train_model.py","title":"Entra\u00eenement"},{"location":"installation/","text":"Guide d'installation complet pour Trip Extraction. Suivez les \u00e9tapes selon votre syst\u00e8me d'exploitation et vos besoins. \ud83d\udccb Pr\u00e9requis Syst\u00e8me Python : Version 3.11 ou sup\u00e9rieure (test\u00e9 sur 3.11 et 3.12) Espace disque : ~1GB pour les mod\u00e8les HuggingFace RAM : Minimum 4GB recommand\u00e9s (8GB pour GPU) Connexion internet : N\u00e9cessaire pour t\u00e9l\u00e9charger les mod\u00e8les (premi\u00e8re utilisation uniquement) Optionnel GPU NVIDIA : Pour acc\u00e9l\u00e9ration CUDA (temps d'entra\u00eenement divis\u00e9 par 4-5) Git : Pour cloner le repository V\u00e9rifier votre version de Python python --version # ou python3 --version Si Python < 3.11, installez une version plus r\u00e9cente depuis python.org \ud83d\ude80 Installation standard \u00c9tape 1 : Cloner le repository git clone <repo-url> cd bootstrap Sans Git ? T\u00e9l\u00e9chargez le ZIP depuis GitHub et d\u00e9compressez-le : unzip bootstrap-main.zip cd bootstrap-main \u00c9tape 2 : Cr\u00e9er un environnement virtuel Fish Shell # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement source .venv/bin/activate.fish # V\u00e9rifier l'activation which python # Devrait afficher: /path/to/bootstrap/.venv/bin/python Bash/Zsh # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement source .venv/bin/activate # V\u00e9rifier l'activation which python # Devrait afficher: /path/to/bootstrap/.venv/bin/python Windows PowerShell # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement .venv\\Scripts\\Activate.ps1 # V\u00e9rifier l'activation where.exe python # Devrait afficher: C:\\path\\to\\bootstrap\\.venv\\Scripts\\python.exe Windows CMD # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement .venv\\Scripts\\activate.bat # V\u00e9rifier l'activation where python Pourquoi un environnement virtuel ? Les environnements virtuels isolent les d\u00e9pendances du projet : \u2705 \u00c9vite les conflits entre projets \u2705 Facilite la reproduction de l'environnement \u2705 Permet des versions de packages diff\u00e9rentes par projet \u00c9tape 3 : Installer les d\u00e9pendances pip install -e . Cette commande installe : Package Version Usage transformers >=4.36.0 Biblioth\u00e8que HuggingFace pour les mod\u00e8les torch >=2.1.0 PyTorch pour le deep learning sentencepiece >=0.1.99 Tokenization pour CamemBERT scikit-learn >=1.3.0 M\u00e9triques et utilitaires ML accelerate >=0.26.0 Acc\u00e9l\u00e9ration GPU/CPU Mise \u00e0 jour des d\u00e9pendances Pour mettre \u00e0 jour toutes les d\u00e9pendances : pip install --upgrade -e . \u00c9tape 4 : Entra\u00eener le mod\u00e8le Obligatoire L'entra\u00eenement est obligatoire la premi\u00e8re fois pour cr\u00e9er le mod\u00e8le classifier. trip-train Dur\u00e9e attendue : Device Temps Recommandation CPU 10-12 min \u2615 Prenez un caf\u00e9 GPU (CUDA) 2-3 min \u26a1 Rapide Apple M1/M2 5-7 min \ud83c\udf4e Interm\u00e9diaire Que fait trip-train ? Le script trip-train : Charge le dataset ( data/training_dataset.json ) Split train/test (80/20) Fine-tune CamemBERT (3 epochs) \u00c9value sur le test set Sauvegarde le mod\u00e8le dans models/departure_arrival_classifier/ \u00c9tape 5 : Tester l'installation trip-demo Si le demo interactif se lance, l'installation est r\u00e9ussie ! \ud83c\udf89 Exemple de session ============================================================ Trip Information Extraction v0.1.0 ============================================================ Entrez des phrases pour extraire les trajets. Commandes: 'quit' ou 'exit' pour quitter \u2708\ufe0f Phrase > Je vais de Paris \u00e0 Lyon \u27a1\ufe0f R\u00e9sultat: Paris \u2192 Lyon \u2708\ufe0f Phrase > quit \ud83d\udc4b Au revoir! \ud83d\udee0\ufe0f Installation pour le d\u00e9veloppement Pour contribuer au projet, installez \u00e9galement les outils de d\u00e9veloppement : pip install -e \".[dev]\" Outils inclus Outil Usage Commande black Formatteur de code black src/ ruff Linter rapide ruff check src/ mypy Type checker mypy src/ pytest Framework de tests pytest tests/ ipython Shell Python am\u00e9lior\u00e9 ipython jupyter Notebooks interactifs jupyter lab V\u00e9rifier les outils # Formatter le code black src/ scripts/ # V\u00e9rifier avec ruff ruff check src/ # Type checking mypy src/ \ud83c\udfaf Configuration GPU (CUDA) V\u00e9rifier CUDA # V\u00e9rifier si CUDA est disponible python -c \"import torch; print(f'CUDA disponible: {torch.cuda.is_available()}')\" python -c \"import torch; print(f'CUDA version: {torch.version.cuda}')\" Installer PyTorch avec CUDA CUDA 11.8 pip install torch --index-url https://download.pytorch.org/whl/cu118 CUDA 12.1 pip install torch --index-url https://download.pytorch.org/whl/cu121 CPU uniquement pip install torch --index-url https://download.pytorch.org/whl/cpu Quelle version CUDA choisir ? V\u00e9rifiez votre version CUDA : nvidia-smi Regardez la ligne CUDA Version: X.Y \ud83e\ude7a V\u00e9rification de l'installation Test programmatique # V\u00e9rifier que tous les composants fonctionnent from trip import TripParser from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier print(\"\u2705 Import r\u00e9ussi\") # Tester NER ner = NERExtractor() print(\"\u2705 NER Extractor charg\u00e9\") # Tester Classifier classifier = DepartureArrivalClassifier() print(\"\u2705 Classifier charg\u00e9\") # Tester Parser complet parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"\u2705 Parsing r\u00e9ussi: {departure} \u2192 {arrival}\") V\u00e9rifier les mod\u00e8les # Lister les mod\u00e8les t\u00e9l\u00e9charg\u00e9s ls -lh models/departure_arrival_classifier/ # Devrait afficher : # config.json # model.safetensors # tokenizer files... \u2757 Probl\u00e8mes courants ModuleNotFoundError: No module named 'trip' Cause : Le package n'est pas install\u00e9 ou l'environnement n'est pas activ\u00e9. Solution : # Activer l'environnement source .venv/bin/activate.fish # ou activate pour bash # R\u00e9installer pip install -e . ImportError: No module named 'transformers' Cause : Les d\u00e9pendances ne sont pas install\u00e9es. Solution : pip install -e . torch.cuda.is_available() retourne False Cause : PyTorch n'a pas le support CUDA ou GPU non d\u00e9tect\u00e9. Solution : # R\u00e9installer PyTorch avec CUDA pip uninstall torch pip install torch --index-url https://download.pytorch.org/whl/cu118 OSError: [Errno 28] No space left on device Cause : Espace disque insuffisant pour les mod\u00e8les (~1GB). Solution : # V\u00e9rifier l'espace disponible df -h . # Lib\u00e9rer de l'espace ou changer de r\u00e9pertoire Entra\u00eenement tr\u00e8s lent (> 20 min) Cause : Pas de GPU ou GPU non utilis\u00e9. Diagnostic : python -c \"import torch; print(torch.cuda.is_available())\" Solutions : - Installer CUDA et PyTorch GPU - Accepter le temps d'entra\u00eenement CPU (10-12 min) - Utiliser un service cloud avec GPU (Google Colab, etc.) UnicodeDecodeError sur Windows Cause : Encodage par d\u00e9faut Windows. Solution : # D\u00e9finir l'encodage UTF-8 set PYTHONUTF8=1 pip install -e . \ud83d\uddd1\ufe0f D\u00e9sinstallation D\u00e9sinstallation compl\u00e8te # D\u00e9sinstaller le package pip uninstall trip # Supprimer l'environnement virtuel rm -rf .venv # Supprimer les mod\u00e8les t\u00e9l\u00e9charg\u00e9s rm -rf models/ # Supprimer le cache HuggingFace (optionnel) rm -rf ~/.cache/huggingface/ Garder les mod\u00e8les Si vous voulez r\u00e9installer plus tard sans ret\u00e9l\u00e9charger les mod\u00e8les : # D\u00e9sinstaller uniquement le package pip uninstall trip # Garder .venv et models/ \ud83d\udcdd Prochaines \u00e9tapes Une fois l'installation termin\u00e9e : \ud83d\udcd6 Consultez le guide d'utilisation pour des exemples \ud83c\udfd7\ufe0f Explorez l' architecture du syst\u00e8me \ud83d\udcda R\u00e9f\u00e9rez-vous \u00e0 l' API pour l'int\u00e9gration \ud83c\udf93 Entra\u00eenez avec vos propres donn\u00e9es (voir README) \ud83d\udca1 Conseils Performance Pour de meilleures performances, utilisez un GPU NVIDIA avec CUDA. Production En production, \u00e9pinglez les versions des d\u00e9pendances : bash pip freeze > requirements.txt Mise \u00e0 jour Gardez les mod\u00e8les \u00e0 jour : bash git pull trip-train","title":"Installation"},{"location":"installation/#prerequis","text":"","title":"\ud83d\udccb Pr\u00e9requis"},{"location":"installation/#systeme","text":"Python : Version 3.11 ou sup\u00e9rieure (test\u00e9 sur 3.11 et 3.12) Espace disque : ~1GB pour les mod\u00e8les HuggingFace RAM : Minimum 4GB recommand\u00e9s (8GB pour GPU) Connexion internet : N\u00e9cessaire pour t\u00e9l\u00e9charger les mod\u00e8les (premi\u00e8re utilisation uniquement)","title":"Syst\u00e8me"},{"location":"installation/#optionnel","text":"GPU NVIDIA : Pour acc\u00e9l\u00e9ration CUDA (temps d'entra\u00eenement divis\u00e9 par 4-5) Git : Pour cloner le repository V\u00e9rifier votre version de Python python --version # ou python3 --version Si Python < 3.11, installez une version plus r\u00e9cente depuis python.org","title":"Optionnel"},{"location":"installation/#installation-standard","text":"","title":"\ud83d\ude80 Installation standard"},{"location":"installation/#etape-1-cloner-le-repository","text":"git clone <repo-url> cd bootstrap Sans Git ? T\u00e9l\u00e9chargez le ZIP depuis GitHub et d\u00e9compressez-le : unzip bootstrap-main.zip cd bootstrap-main","title":"\u00c9tape 1 : Cloner le repository"},{"location":"installation/#etape-2-creer-un-environnement-virtuel","text":"Fish Shell # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement source .venv/bin/activate.fish # V\u00e9rifier l'activation which python # Devrait afficher: /path/to/bootstrap/.venv/bin/python Bash/Zsh # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement source .venv/bin/activate # V\u00e9rifier l'activation which python # Devrait afficher: /path/to/bootstrap/.venv/bin/python Windows PowerShell # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement .venv\\Scripts\\Activate.ps1 # V\u00e9rifier l'activation where.exe python # Devrait afficher: C:\\path\\to\\bootstrap\\.venv\\Scripts\\python.exe Windows CMD # Cr\u00e9er l'environnement python -m venv .venv # Activer l'environnement .venv\\Scripts\\activate.bat # V\u00e9rifier l'activation where python Pourquoi un environnement virtuel ? Les environnements virtuels isolent les d\u00e9pendances du projet : \u2705 \u00c9vite les conflits entre projets \u2705 Facilite la reproduction de l'environnement \u2705 Permet des versions de packages diff\u00e9rentes par projet","title":"\u00c9tape 2 : Cr\u00e9er un environnement virtuel"},{"location":"installation/#etape-3-installer-les-dependances","text":"pip install -e . Cette commande installe : Package Version Usage transformers >=4.36.0 Biblioth\u00e8que HuggingFace pour les mod\u00e8les torch >=2.1.0 PyTorch pour le deep learning sentencepiece >=0.1.99 Tokenization pour CamemBERT scikit-learn >=1.3.0 M\u00e9triques et utilitaires ML accelerate >=0.26.0 Acc\u00e9l\u00e9ration GPU/CPU Mise \u00e0 jour des d\u00e9pendances Pour mettre \u00e0 jour toutes les d\u00e9pendances : pip install --upgrade -e .","title":"\u00c9tape 3 : Installer les d\u00e9pendances"},{"location":"installation/#etape-4-entrainer-le-modele","text":"Obligatoire L'entra\u00eenement est obligatoire la premi\u00e8re fois pour cr\u00e9er le mod\u00e8le classifier. trip-train Dur\u00e9e attendue : Device Temps Recommandation CPU 10-12 min \u2615 Prenez un caf\u00e9 GPU (CUDA) 2-3 min \u26a1 Rapide Apple M1/M2 5-7 min \ud83c\udf4e Interm\u00e9diaire Que fait trip-train ? Le script trip-train : Charge le dataset ( data/training_dataset.json ) Split train/test (80/20) Fine-tune CamemBERT (3 epochs) \u00c9value sur le test set Sauvegarde le mod\u00e8le dans models/departure_arrival_classifier/","title":"\u00c9tape 4 : Entra\u00eener le mod\u00e8le"},{"location":"installation/#etape-5-tester-linstallation","text":"trip-demo Si le demo interactif se lance, l'installation est r\u00e9ussie ! \ud83c\udf89","title":"\u00c9tape 5 : Tester l'installation"},{"location":"installation/#exemple-de-session","text":"============================================================ Trip Information Extraction v0.1.0 ============================================================ Entrez des phrases pour extraire les trajets. Commandes: 'quit' ou 'exit' pour quitter \u2708\ufe0f Phrase > Je vais de Paris \u00e0 Lyon \u27a1\ufe0f R\u00e9sultat: Paris \u2192 Lyon \u2708\ufe0f Phrase > quit \ud83d\udc4b Au revoir!","title":"Exemple de session"},{"location":"installation/#installation-pour-le-developpement","text":"Pour contribuer au projet, installez \u00e9galement les outils de d\u00e9veloppement : pip install -e \".[dev]\"","title":"\ud83d\udee0\ufe0f Installation pour le d\u00e9veloppement"},{"location":"installation/#outils-inclus","text":"Outil Usage Commande black Formatteur de code black src/ ruff Linter rapide ruff check src/ mypy Type checker mypy src/ pytest Framework de tests pytest tests/ ipython Shell Python am\u00e9lior\u00e9 ipython jupyter Notebooks interactifs jupyter lab","title":"Outils inclus"},{"location":"installation/#verifier-les-outils","text":"# Formatter le code black src/ scripts/ # V\u00e9rifier avec ruff ruff check src/ # Type checking mypy src/","title":"V\u00e9rifier les outils"},{"location":"installation/#configuration-gpu-cuda","text":"","title":"\ud83c\udfaf Configuration GPU (CUDA)"},{"location":"installation/#verifier-cuda","text":"# V\u00e9rifier si CUDA est disponible python -c \"import torch; print(f'CUDA disponible: {torch.cuda.is_available()}')\" python -c \"import torch; print(f'CUDA version: {torch.version.cuda}')\"","title":"V\u00e9rifier CUDA"},{"location":"installation/#installer-pytorch-avec-cuda","text":"CUDA 11.8 pip install torch --index-url https://download.pytorch.org/whl/cu118 CUDA 12.1 pip install torch --index-url https://download.pytorch.org/whl/cu121 CPU uniquement pip install torch --index-url https://download.pytorch.org/whl/cpu Quelle version CUDA choisir ? V\u00e9rifiez votre version CUDA : nvidia-smi Regardez la ligne CUDA Version: X.Y","title":"Installer PyTorch avec CUDA"},{"location":"installation/#verification-de-linstallation","text":"","title":"\ud83e\ude7a V\u00e9rification de l'installation"},{"location":"installation/#test-programmatique","text":"# V\u00e9rifier que tous les composants fonctionnent from trip import TripParser from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier print(\"\u2705 Import r\u00e9ussi\") # Tester NER ner = NERExtractor() print(\"\u2705 NER Extractor charg\u00e9\") # Tester Classifier classifier = DepartureArrivalClassifier() print(\"\u2705 Classifier charg\u00e9\") # Tester Parser complet parser = TripParser() departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"\u2705 Parsing r\u00e9ussi: {departure} \u2192 {arrival}\")","title":"Test programmatique"},{"location":"installation/#verifier-les-modeles","text":"# Lister les mod\u00e8les t\u00e9l\u00e9charg\u00e9s ls -lh models/departure_arrival_classifier/ # Devrait afficher : # config.json # model.safetensors # tokenizer files...","title":"V\u00e9rifier les mod\u00e8les"},{"location":"installation/#problemes-courants","text":"","title":"\u2757 Probl\u00e8mes courants"},{"location":"installation/#modulenotfounderror-no-module-named-trip","text":"Cause : Le package n'est pas install\u00e9 ou l'environnement n'est pas activ\u00e9. Solution : # Activer l'environnement source .venv/bin/activate.fish # ou activate pour bash # R\u00e9installer pip install -e .","title":"ModuleNotFoundError: No module named 'trip'"},{"location":"installation/#importerror-no-module-named-transformers","text":"Cause : Les d\u00e9pendances ne sont pas install\u00e9es. Solution : pip install -e .","title":"ImportError: No module named 'transformers'"},{"location":"installation/#torchcudais_available-retourne-false","text":"Cause : PyTorch n'a pas le support CUDA ou GPU non d\u00e9tect\u00e9. Solution : # R\u00e9installer PyTorch avec CUDA pip uninstall torch pip install torch --index-url https://download.pytorch.org/whl/cu118","title":"torch.cuda.is_available() retourne False"},{"location":"installation/#oserror-errno-28-no-space-left-on-device","text":"Cause : Espace disque insuffisant pour les mod\u00e8les (~1GB). Solution : # V\u00e9rifier l'espace disponible df -h . # Lib\u00e9rer de l'espace ou changer de r\u00e9pertoire","title":"OSError: [Errno 28] No space left on device"},{"location":"installation/#entrainement-tres-lent-20-min","text":"Cause : Pas de GPU ou GPU non utilis\u00e9. Diagnostic : python -c \"import torch; print(torch.cuda.is_available())\" Solutions : - Installer CUDA et PyTorch GPU - Accepter le temps d'entra\u00eenement CPU (10-12 min) - Utiliser un service cloud avec GPU (Google Colab, etc.)","title":"Entra\u00eenement tr\u00e8s lent (&gt; 20 min)"},{"location":"installation/#unicodedecodeerror-sur-windows","text":"Cause : Encodage par d\u00e9faut Windows. Solution : # D\u00e9finir l'encodage UTF-8 set PYTHONUTF8=1 pip install -e .","title":"UnicodeDecodeError sur Windows"},{"location":"installation/#desinstallation","text":"","title":"\ud83d\uddd1\ufe0f D\u00e9sinstallation"},{"location":"installation/#desinstallation-complete","text":"# D\u00e9sinstaller le package pip uninstall trip # Supprimer l'environnement virtuel rm -rf .venv # Supprimer les mod\u00e8les t\u00e9l\u00e9charg\u00e9s rm -rf models/ # Supprimer le cache HuggingFace (optionnel) rm -rf ~/.cache/huggingface/","title":"D\u00e9sinstallation compl\u00e8te"},{"location":"installation/#garder-les-modeles","text":"Si vous voulez r\u00e9installer plus tard sans ret\u00e9l\u00e9charger les mod\u00e8les : # D\u00e9sinstaller uniquement le package pip uninstall trip # Garder .venv et models/","title":"Garder les mod\u00e8les"},{"location":"installation/#prochaines-etapes","text":"Une fois l'installation termin\u00e9e : \ud83d\udcd6 Consultez le guide d'utilisation pour des exemples \ud83c\udfd7\ufe0f Explorez l' architecture du syst\u00e8me \ud83d\udcda R\u00e9f\u00e9rez-vous \u00e0 l' API pour l'int\u00e9gration \ud83c\udf93 Entra\u00eenez avec vos propres donn\u00e9es (voir README)","title":"\ud83d\udcdd Prochaines \u00e9tapes"},{"location":"installation/#conseils","text":"Performance Pour de meilleures performances, utilisez un GPU NVIDIA avec CUDA. Production En production, \u00e9pinglez les versions des d\u00e9pendances : bash pip freeze > requirements.txt Mise \u00e0 jour Gardez les mod\u00e8les \u00e0 jour : bash git pull trip-train","title":"\ud83d\udca1 Conseils"},{"location":"usage/","text":"Guide complet d'utilisation de Trip Extraction avec exemples interactifs et cas d'usage avanc\u00e9s. \ud83d\udda5\ufe0f Interface CLI Demo interactif Le moyen le plus rapide de tester le syst\u00e8me : trip-demo Exemple de session ============================================================ Trip Information Extraction v0.1.0 ============================================================ Entrez des phrases pour extraire les trajets. Commandes: 'quit' ou 'exit' pour quitter \u2708\ufe0f Phrase > Je vais de Paris \u00e0 Lyon \u27a1\ufe0f R\u00e9sultat: Paris \u2192 Lyon \u2708\ufe0f Phrase > Train depuis Marseille vers Nice \u27a1\ufe0f R\u00e9sultat: Marseille \u2192 Nice \u2708\ufe0f Phrase > Comment aller \u00e0 Toulouse depuis Bordeaux ? \u27a1\ufe0f R\u00e9sultat: Bordeaux \u2192 Toulouse \u2708\ufe0f Phrase > quit \ud83d\udc4b Au revoir! Options CLI Aide trip-demo --help Affiche l'aide et les options disponibles. Mode verbose trip-demo --verbose Affiche des informations d\u00e9taill\u00e9es sur le traitement. \ud83d\udc0d API Python Exemple basique L'usage le plus simple pour extraire un trajet : from trip import TripParser # Initialiser le parser parser = TripParser() # Extraire un trajet departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"D\u00e9part: {departure}\") print(f\"Arriv\u00e9e: {arrival}\") # Output: # D\u00e9part: Paris # Arriv\u00e9e: Lyon Avec gestion d'erreurs Production-ready avec gestion compl\u00e8te des erreurs : from trip import TripParser from trip.utils import ( TripExtractionError, InvalidInputError, InsufficientLocationsError, LowConfidenceError ) parser = TripParser() def extract_trip_safe(text: str): \"\"\"Extraction s\u00e9curis\u00e9e avec gestion d'erreurs.\"\"\" try: departure, arrival = parser.parse_trip(text) if departure and arrival: return f\"\u2705 {departure} \u2192 {arrival}\" else: return \"\u26a0\ufe0f Trajet incomplet d\u00e9tect\u00e9\" except InvalidInputError: return \"\u274c Texte vide ou invalide\" except InsufficientLocationsError: return \"\u274c Pas assez de villes (minimum 2)\" except LowConfidenceError: return \"\u274c Confiance trop faible\" except TripExtractionError as e: return f\"\u274c Erreur: {e}\" # Tester diff\u00e9rents cas print(extract_trip_safe(\"Je vais de Paris \u00e0 Lyon\")) print(extract_trip_safe(\"\")) print(extract_trip_safe(\"Je vais \u00e0 Paris\")) Utilisation avanc\u00e9e : composants s\u00e9par\u00e9s Utiliser NER et Classifier ind\u00e9pendamment pour plus de contr\u00f4le : from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier # Initialiser les composants ner = NERExtractor() classifier = DepartureArrivalClassifier() text = \"Je vais de Paris \u00e0 Lyon puis Marseille\" # \u00c9tape 1 : Extraire toutes les villes locations = ner.extract_locations(text) print(f\"Villes d\u00e9tect\u00e9es: {locations}\") # \u00c9tape 2 : Classifier chaque ville for location in locations: role, confidence = classifier.classify_location(text, location) print(f\" {location}: {role} (confiance: {confidence:.1%})\") \ud83d\udcdd Exemples de phrases support\u00e9es Syntaxe simple et directe from trip import TripParser parser = TripParser() phrases_simples = [ \"De Paris \u00e0 Lyon\", \"Paris Lyon\", \"Train de Marseille vers Nice\", \"Vol Toulouse Bordeaux\", \"Aller de Lille \u00e0 Strasbourg\" ] print(\"SYNTAXE SIMPLE\") print(\"=\" * 50) for phrase in phrases_simples: d, a = parser.parse_trip(phrase) print(f\"{phrase:35} \u2192 {d:12} \u2192 {a}\") Questions et formulations complexes from trip import TripParser parser = TripParser() questions = [ \"Comment aller \u00e0 Marseille depuis Toulouse ?\", \"O\u00f9 prendre le train pour Nice depuis Paris ?\", \"Quel est le chemin de Bordeaux vers Nantes ?\", \"Comment je fais pour aller \u00e0 Lille ?\" ] print(\"QUESTIONS\") print(\"=\" * 50) for q in questions: d, a = parser.parse_trip(q) if d and a: print(f\"{d:12} \u2192 {a:12} | {q}\") else: print(f\"Non d\u00e9tect\u00e9 | {q}\") Syntaxe invers\u00e9e (destination avant d\u00e9part) from trip import TripParser parser = TripParser() phrases_inversees = [ \"\u00c0 Lille depuis Paris\", \"Vers Lyon de Paris\", \"Pour Nice depuis Marseille\", \"Destination Bordeaux d\u00e9part Toulouse\" ] print(\"SYNTAXE INVERS\u00c9E\") print(\"=\" * 50) for phrase in phrases_inversees: d, a = parser.parse_trip(phrase) print(f\"{phrase:40} \u2192 {d:12} \u2192 {a}\") Avec contexte temporel ou modal from trip import TripParser parser = TripParser() phrases_contexte = [ \"Demain je vais de Nice \u00e0 Cannes\", \"Train de 8h de Paris \u00e0 Lyon\", \"Vol du matin Toulouse Bordeaux\", \"Je pars lundi de Marseille pour aller \u00e0 Paris\" ] print(\"AVEC CONTEXTE\") print(\"=\" * 50) for phrase in phrases_contexte: d, a = parser.parse_trip(phrase) print(f\"{phrase:50} \u2192 {d:12} \u2192 {a}\") \ud83d\udd04 Batch processing Traiter plusieurs phrases efficacement : from trip import TripParser from typing import List, Tuple, Optional parser = TripParser() def batch_extract( phrases: List[str] ) -> List[Tuple[str, Optional[str], Optional[str]]]: \"\"\" Extrait les trajets pour plusieurs phrases. Returns: Liste de tuples (phrase, departure, arrival) \"\"\" results = [] for phrase in phrases: try: departure, arrival = parser.parse_trip(phrase) results.append((phrase, departure, arrival)) except Exception as e: results.append((phrase, None, None)) return results # Exemple d'utilisation phrases = [ \"Je vais de Paris \u00e0 Lyon\", \"Train de Marseille \u00e0 Nice\", \"Vol Toulouse Bordeaux\", \"Comment aller \u00e0 Lille ?\", # Ville manquante ] results = batch_extract(phrases) print(\"R\u00c9SULTATS BATCH\") print(\"=\" * 60) for phrase, d, a in results: if d and a: print(f\"\u2705 {d:12} \u2192 {a:12} | {phrase}\") else: print(f\"\u274c Non d\u00e9tect\u00e9 | {phrase}\") Batch avec statistiques from trip import TripParser from collections import Counter parser = TripParser() phrases = [ \"De Paris \u00e0 Lyon\", \"Paris Marseille\", \"Lyon Nice\", \"Paris Toulouse\", \"Marseille Paris\", \"Lyon Marseille\" ] # Extraire tous les trajets routes = [] departures = [] arrivals = [] for phrase in phrases: d, a = parser.parse_trip(phrase) if d and a: routes.append(f\"{d} \u2192 {a}\") departures.append(d) arrivals.append(a) # Statistiques print(\"STATISTIQUES\") print(\"=\" * 40) print(f\"Total phrases: {len(phrases)}\") print(f\"Trajets extraits: {len(routes)}\") print(f\"\\nVilles de d\u00e9part les plus fr\u00e9quentes:\") for city, count in Counter(departures).most_common(3): print(f\" {city}: {count}x\") print(f\"\\nVilles d'arriv\u00e9e les plus fr\u00e9quentes:\") for city, count in Counter(arrivals).most_common(3): print(f\" {city}: {count}x\") \u2699\ufe0f Configuration avanc\u00e9e Ajuster le seuil de confiance Contr\u00f4ler la sensibilit\u00e9 de la classification : from trip.utils import get_config # R\u00e9cup\u00e9rer la configuration config = get_config() # Seuil par d\u00e9faut : 0.5 (50%) print(f\"Seuil actuel: {config.model.confidence_threshold}\") # Rendre plus strict (moins de faux positifs) config.model.confidence_threshold = 0.8 # Rendre plus permissif (plus de r\u00e9sultats) config.model.confidence_threshold = 0.3 Impact du seuil Seuil \u00e9lev\u00e9 (0.7-0.9) : Plus pr\u00e9cis mais peut rejeter des trajets valides Seuil bas (0.3-0.5) : Plus de r\u00e9sultats mais risque de faux positifs Forcer l'utilisation CPU/GPU from trip.utils import get_config config = get_config() # Forcer CPU (utile pour le debugging) config.model.device = \"cpu\" # Forcer GPU si disponible config.model.device = \"cuda\" # Auto-d\u00e9tection (d\u00e9faut) import torch config.model.device = \"cuda\" if torch.cuda.is_available() else \"cpu\" print(f\"Device utilis\u00e9: {config.model.device}\") Configuration du logging from trip.utils import setup_logging import logging # Mode production : INFO uniquement setup_logging(level=logging.INFO) # Mode debug : tous les d\u00e9tails setup_logging(level=logging.DEBUG) # Avec fichier de log setup_logging( level=logging.INFO, log_file=\"trip.log\" ) # Personnalis\u00e9 setup_logging( level=logging.WARNING, log_file=\"trip_errors.log\", format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\" ) Modifier les mod\u00e8les utilis\u00e9s from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier # Utiliser un autre mod\u00e8le NER ner = NERExtractor(model_name=\"autre-modele-camembert-ner\") # Utiliser un mod\u00e8le classifier personnalis\u00e9 classifier = DepartureArrivalClassifier( model_path=\"./mon_modele_custom/\" ) \ud83c\udfaf Cas d'usage r\u00e9els 1. Chatbot de voyage from trip import TripParser class TravelChatbot: def __init__(self): self.parser = TripParser() def handle_message(self, user_message: str) -> str: try: departure, arrival = self.parser.parse_trip(user_message) if departure and arrival: return ( f\"Je comprends que vous souhaitez voyager \" f\"de {departure} \u00e0 {arrival}. \" f\"Je recherche les options disponibles...\" ) else: return \"Pouvez-vous pr\u00e9ciser votre trajet ?\" except Exception: return \"D\u00e9sol\u00e9, je n'ai pas compris votre demande.\" # Utilisation bot = TravelChatbot() response = bot.handle_message(\"Je veux aller \u00e0 Paris depuis Lyon\") print(response) 2. Analyse de logs from trip import TripParser def analyze_travel_logs(log_file: str): \"\"\"Analyse un fichier de logs pour extraire les trajets.\"\"\" parser = TripParser() trips = [] with open(log_file, 'r') as f: for line in f: try: d, a = parser.parse_trip(line) if d and a: trips.append((d, a)) except: continue return trips # Analyse trips = analyze_travel_logs(\"user_queries.log\") print(f\"Trajets trouv\u00e9s: {len(trips)}\") 3. API REST from fastapi import FastAPI, HTTPException from pydantic import BaseModel from trip import TripParser app = FastAPI() parser = TripParser() class TripRequest(BaseModel): text: str class TripResponse(BaseModel): departure: str | None arrival: str | None @app.post(\"/extract-trip\", response_model=TripResponse) async def extract_trip(request: TripRequest): try: departure, arrival = parser.parse_trip(request.text) return TripResponse(departure=departure, arrival=arrival) except Exception as e: raise HTTPException(status_code=400, detail=str(e)) \ud83d\udcca Monitoring et m\u00e9triques Mesurer les performances import time from trip import TripParser parser = TripParser() phrases = [\"Je vais de Paris \u00e0 Lyon\"] * 100 # Mesurer le temps start = time.time() for phrase in phrases: parser.parse_trip(phrase) end = time.time() avg_time = (end - start) / len(phrases) print(f\"Temps moyen: {avg_time*1000:.2f}ms par phrase\") print(f\"D\u00e9bit: {len(phrases)/(end-start):.1f} phrases/seconde\") \ud83d\udca1 Bonnes pratiques Performance R\u00e9utilisez l'instance TripParser au lieu d'en cr\u00e9er une nouvelle \u00e0 chaque fois Pour du batch, utilisez un GPU si disponible Utilisez le logging pour d\u00e9bugger en d\u00e9veloppement Gestion d'erreurs Toujours g\u00e9rer les exceptions en production Loggez les erreurs pour analyse ult\u00e9rieure Retournez des messages d'erreur clairs aux utilisateurs Int\u00e9gration Validez l'entr\u00e9e utilisateur avant le parsing Cachez les r\u00e9sultats si pertinent Ajoutez des m\u00e9triques pour monitorer l'usage \ud83d\udd17 Prochaines \u00e9tapes Consultez l' Architecture pour comprendre le fonctionnement interne Explorez l' API Reference pour tous les d\u00e9tails techniques Voir le README pour l'entra\u00eenement avec vos propres donn\u00e9es # Mode debug setup_logging(level=logging.DEBUG) # Avec fichier de log setup_logging(level=logging.INFO, log_file=\"trip.log\")","title":"Utilisation"},{"location":"usage/#interface-cli","text":"","title":"\ud83d\udda5\ufe0f Interface CLI"},{"location":"usage/#demo-interactif","text":"Le moyen le plus rapide de tester le syst\u00e8me : trip-demo","title":"Demo interactif"},{"location":"usage/#exemple-de-session","text":"============================================================ Trip Information Extraction v0.1.0 ============================================================ Entrez des phrases pour extraire les trajets. Commandes: 'quit' ou 'exit' pour quitter \u2708\ufe0f Phrase > Je vais de Paris \u00e0 Lyon \u27a1\ufe0f R\u00e9sultat: Paris \u2192 Lyon \u2708\ufe0f Phrase > Train depuis Marseille vers Nice \u27a1\ufe0f R\u00e9sultat: Marseille \u2192 Nice \u2708\ufe0f Phrase > Comment aller \u00e0 Toulouse depuis Bordeaux ? \u27a1\ufe0f R\u00e9sultat: Bordeaux \u2192 Toulouse \u2708\ufe0f Phrase > quit \ud83d\udc4b Au revoir!","title":"Exemple de session"},{"location":"usage/#options-cli","text":"Aide trip-demo --help Affiche l'aide et les options disponibles. Mode verbose trip-demo --verbose Affiche des informations d\u00e9taill\u00e9es sur le traitement.","title":"Options CLI"},{"location":"usage/#api-python","text":"","title":"\ud83d\udc0d API Python"},{"location":"usage/#exemple-basique","text":"L'usage le plus simple pour extraire un trajet : from trip import TripParser # Initialiser le parser parser = TripParser() # Extraire un trajet departure, arrival = parser.parse_trip(\"Je vais de Paris \u00e0 Lyon\") print(f\"D\u00e9part: {departure}\") print(f\"Arriv\u00e9e: {arrival}\") # Output: # D\u00e9part: Paris # Arriv\u00e9e: Lyon","title":"Exemple basique"},{"location":"usage/#avec-gestion-derreurs","text":"Production-ready avec gestion compl\u00e8te des erreurs : from trip import TripParser from trip.utils import ( TripExtractionError, InvalidInputError, InsufficientLocationsError, LowConfidenceError ) parser = TripParser() def extract_trip_safe(text: str): \"\"\"Extraction s\u00e9curis\u00e9e avec gestion d'erreurs.\"\"\" try: departure, arrival = parser.parse_trip(text) if departure and arrival: return f\"\u2705 {departure} \u2192 {arrival}\" else: return \"\u26a0\ufe0f Trajet incomplet d\u00e9tect\u00e9\" except InvalidInputError: return \"\u274c Texte vide ou invalide\" except InsufficientLocationsError: return \"\u274c Pas assez de villes (minimum 2)\" except LowConfidenceError: return \"\u274c Confiance trop faible\" except TripExtractionError as e: return f\"\u274c Erreur: {e}\" # Tester diff\u00e9rents cas print(extract_trip_safe(\"Je vais de Paris \u00e0 Lyon\")) print(extract_trip_safe(\"\")) print(extract_trip_safe(\"Je vais \u00e0 Paris\"))","title":"Avec gestion d'erreurs"},{"location":"usage/#utilisation-avancee-composants-separes","text":"Utiliser NER et Classifier ind\u00e9pendamment pour plus de contr\u00f4le : from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier # Initialiser les composants ner = NERExtractor() classifier = DepartureArrivalClassifier() text = \"Je vais de Paris \u00e0 Lyon puis Marseille\" # \u00c9tape 1 : Extraire toutes les villes locations = ner.extract_locations(text) print(f\"Villes d\u00e9tect\u00e9es: {locations}\") # \u00c9tape 2 : Classifier chaque ville for location in locations: role, confidence = classifier.classify_location(text, location) print(f\" {location}: {role} (confiance: {confidence:.1%})\")","title":"Utilisation avanc\u00e9e : composants s\u00e9par\u00e9s"},{"location":"usage/#exemples-de-phrases-supportees","text":"","title":"\ud83d\udcdd Exemples de phrases support\u00e9es"},{"location":"usage/#syntaxe-simple-et-directe","text":"from trip import TripParser parser = TripParser() phrases_simples = [ \"De Paris \u00e0 Lyon\", \"Paris Lyon\", \"Train de Marseille vers Nice\", \"Vol Toulouse Bordeaux\", \"Aller de Lille \u00e0 Strasbourg\" ] print(\"SYNTAXE SIMPLE\") print(\"=\" * 50) for phrase in phrases_simples: d, a = parser.parse_trip(phrase) print(f\"{phrase:35} \u2192 {d:12} \u2192 {a}\")","title":"Syntaxe simple et directe"},{"location":"usage/#questions-et-formulations-complexes","text":"from trip import TripParser parser = TripParser() questions = [ \"Comment aller \u00e0 Marseille depuis Toulouse ?\", \"O\u00f9 prendre le train pour Nice depuis Paris ?\", \"Quel est le chemin de Bordeaux vers Nantes ?\", \"Comment je fais pour aller \u00e0 Lille ?\" ] print(\"QUESTIONS\") print(\"=\" * 50) for q in questions: d, a = parser.parse_trip(q) if d and a: print(f\"{d:12} \u2192 {a:12} | {q}\") else: print(f\"Non d\u00e9tect\u00e9 | {q}\")","title":"Questions et formulations complexes"},{"location":"usage/#syntaxe-inversee-destination-avant-depart","text":"from trip import TripParser parser = TripParser() phrases_inversees = [ \"\u00c0 Lille depuis Paris\", \"Vers Lyon de Paris\", \"Pour Nice depuis Marseille\", \"Destination Bordeaux d\u00e9part Toulouse\" ] print(\"SYNTAXE INVERS\u00c9E\") print(\"=\" * 50) for phrase in phrases_inversees: d, a = parser.parse_trip(phrase) print(f\"{phrase:40} \u2192 {d:12} \u2192 {a}\")","title":"Syntaxe invers\u00e9e (destination avant d\u00e9part)"},{"location":"usage/#avec-contexte-temporel-ou-modal","text":"from trip import TripParser parser = TripParser() phrases_contexte = [ \"Demain je vais de Nice \u00e0 Cannes\", \"Train de 8h de Paris \u00e0 Lyon\", \"Vol du matin Toulouse Bordeaux\", \"Je pars lundi de Marseille pour aller \u00e0 Paris\" ] print(\"AVEC CONTEXTE\") print(\"=\" * 50) for phrase in phrases_contexte: d, a = parser.parse_trip(phrase) print(f\"{phrase:50} \u2192 {d:12} \u2192 {a}\")","title":"Avec contexte temporel ou modal"},{"location":"usage/#batch-processing","text":"Traiter plusieurs phrases efficacement : from trip import TripParser from typing import List, Tuple, Optional parser = TripParser() def batch_extract( phrases: List[str] ) -> List[Tuple[str, Optional[str], Optional[str]]]: \"\"\" Extrait les trajets pour plusieurs phrases. Returns: Liste de tuples (phrase, departure, arrival) \"\"\" results = [] for phrase in phrases: try: departure, arrival = parser.parse_trip(phrase) results.append((phrase, departure, arrival)) except Exception as e: results.append((phrase, None, None)) return results # Exemple d'utilisation phrases = [ \"Je vais de Paris \u00e0 Lyon\", \"Train de Marseille \u00e0 Nice\", \"Vol Toulouse Bordeaux\", \"Comment aller \u00e0 Lille ?\", # Ville manquante ] results = batch_extract(phrases) print(\"R\u00c9SULTATS BATCH\") print(\"=\" * 60) for phrase, d, a in results: if d and a: print(f\"\u2705 {d:12} \u2192 {a:12} | {phrase}\") else: print(f\"\u274c Non d\u00e9tect\u00e9 | {phrase}\")","title":"\ud83d\udd04 Batch processing"},{"location":"usage/#batch-avec-statistiques","text":"from trip import TripParser from collections import Counter parser = TripParser() phrases = [ \"De Paris \u00e0 Lyon\", \"Paris Marseille\", \"Lyon Nice\", \"Paris Toulouse\", \"Marseille Paris\", \"Lyon Marseille\" ] # Extraire tous les trajets routes = [] departures = [] arrivals = [] for phrase in phrases: d, a = parser.parse_trip(phrase) if d and a: routes.append(f\"{d} \u2192 {a}\") departures.append(d) arrivals.append(a) # Statistiques print(\"STATISTIQUES\") print(\"=\" * 40) print(f\"Total phrases: {len(phrases)}\") print(f\"Trajets extraits: {len(routes)}\") print(f\"\\nVilles de d\u00e9part les plus fr\u00e9quentes:\") for city, count in Counter(departures).most_common(3): print(f\" {city}: {count}x\") print(f\"\\nVilles d'arriv\u00e9e les plus fr\u00e9quentes:\") for city, count in Counter(arrivals).most_common(3): print(f\" {city}: {count}x\")","title":"Batch avec statistiques"},{"location":"usage/#configuration-avancee","text":"","title":"\u2699\ufe0f Configuration avanc\u00e9e"},{"location":"usage/#ajuster-le-seuil-de-confiance","text":"Contr\u00f4ler la sensibilit\u00e9 de la classification : from trip.utils import get_config # R\u00e9cup\u00e9rer la configuration config = get_config() # Seuil par d\u00e9faut : 0.5 (50%) print(f\"Seuil actuel: {config.model.confidence_threshold}\") # Rendre plus strict (moins de faux positifs) config.model.confidence_threshold = 0.8 # Rendre plus permissif (plus de r\u00e9sultats) config.model.confidence_threshold = 0.3 Impact du seuil Seuil \u00e9lev\u00e9 (0.7-0.9) : Plus pr\u00e9cis mais peut rejeter des trajets valides Seuil bas (0.3-0.5) : Plus de r\u00e9sultats mais risque de faux positifs","title":"Ajuster le seuil de confiance"},{"location":"usage/#forcer-lutilisation-cpugpu","text":"from trip.utils import get_config config = get_config() # Forcer CPU (utile pour le debugging) config.model.device = \"cpu\" # Forcer GPU si disponible config.model.device = \"cuda\" # Auto-d\u00e9tection (d\u00e9faut) import torch config.model.device = \"cuda\" if torch.cuda.is_available() else \"cpu\" print(f\"Device utilis\u00e9: {config.model.device}\")","title":"Forcer l'utilisation CPU/GPU"},{"location":"usage/#configuration-du-logging","text":"from trip.utils import setup_logging import logging # Mode production : INFO uniquement setup_logging(level=logging.INFO) # Mode debug : tous les d\u00e9tails setup_logging(level=logging.DEBUG) # Avec fichier de log setup_logging( level=logging.INFO, log_file=\"trip.log\" ) # Personnalis\u00e9 setup_logging( level=logging.WARNING, log_file=\"trip_errors.log\", format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\" )","title":"Configuration du logging"},{"location":"usage/#modifier-les-modeles-utilises","text":"from trip.ner_extractor import NERExtractor from trip.departure_arrival_classifier import DepartureArrivalClassifier # Utiliser un autre mod\u00e8le NER ner = NERExtractor(model_name=\"autre-modele-camembert-ner\") # Utiliser un mod\u00e8le classifier personnalis\u00e9 classifier = DepartureArrivalClassifier( model_path=\"./mon_modele_custom/\" )","title":"Modifier les mod\u00e8les utilis\u00e9s"},{"location":"usage/#cas-dusage-reels","text":"","title":"\ud83c\udfaf Cas d'usage r\u00e9els"},{"location":"usage/#1-chatbot-de-voyage","text":"from trip import TripParser class TravelChatbot: def __init__(self): self.parser = TripParser() def handle_message(self, user_message: str) -> str: try: departure, arrival = self.parser.parse_trip(user_message) if departure and arrival: return ( f\"Je comprends que vous souhaitez voyager \" f\"de {departure} \u00e0 {arrival}. \" f\"Je recherche les options disponibles...\" ) else: return \"Pouvez-vous pr\u00e9ciser votre trajet ?\" except Exception: return \"D\u00e9sol\u00e9, je n'ai pas compris votre demande.\" # Utilisation bot = TravelChatbot() response = bot.handle_message(\"Je veux aller \u00e0 Paris depuis Lyon\") print(response)","title":"1. Chatbot de voyage"},{"location":"usage/#2-analyse-de-logs","text":"from trip import TripParser def analyze_travel_logs(log_file: str): \"\"\"Analyse un fichier de logs pour extraire les trajets.\"\"\" parser = TripParser() trips = [] with open(log_file, 'r') as f: for line in f: try: d, a = parser.parse_trip(line) if d and a: trips.append((d, a)) except: continue return trips # Analyse trips = analyze_travel_logs(\"user_queries.log\") print(f\"Trajets trouv\u00e9s: {len(trips)}\")","title":"2. Analyse de logs"},{"location":"usage/#3-api-rest","text":"from fastapi import FastAPI, HTTPException from pydantic import BaseModel from trip import TripParser app = FastAPI() parser = TripParser() class TripRequest(BaseModel): text: str class TripResponse(BaseModel): departure: str | None arrival: str | None @app.post(\"/extract-trip\", response_model=TripResponse) async def extract_trip(request: TripRequest): try: departure, arrival = parser.parse_trip(request.text) return TripResponse(departure=departure, arrival=arrival) except Exception as e: raise HTTPException(status_code=400, detail=str(e))","title":"3. API REST"},{"location":"usage/#monitoring-et-metriques","text":"","title":"\ud83d\udcca Monitoring et m\u00e9triques"},{"location":"usage/#mesurer-les-performances","text":"import time from trip import TripParser parser = TripParser() phrases = [\"Je vais de Paris \u00e0 Lyon\"] * 100 # Mesurer le temps start = time.time() for phrase in phrases: parser.parse_trip(phrase) end = time.time() avg_time = (end - start) / len(phrases) print(f\"Temps moyen: {avg_time*1000:.2f}ms par phrase\") print(f\"D\u00e9bit: {len(phrases)/(end-start):.1f} phrases/seconde\")","title":"Mesurer les performances"},{"location":"usage/#bonnes-pratiques","text":"Performance R\u00e9utilisez l'instance TripParser au lieu d'en cr\u00e9er une nouvelle \u00e0 chaque fois Pour du batch, utilisez un GPU si disponible Utilisez le logging pour d\u00e9bugger en d\u00e9veloppement Gestion d'erreurs Toujours g\u00e9rer les exceptions en production Loggez les erreurs pour analyse ult\u00e9rieure Retournez des messages d'erreur clairs aux utilisateurs Int\u00e9gration Validez l'entr\u00e9e utilisateur avant le parsing Cachez les r\u00e9sultats si pertinent Ajoutez des m\u00e9triques pour monitorer l'usage","title":"\ud83d\udca1 Bonnes pratiques"},{"location":"usage/#prochaines-etapes","text":"Consultez l' Architecture pour comprendre le fonctionnement interne Explorez l' API Reference pour tous les d\u00e9tails techniques Voir le README pour l'entra\u00eenement avec vos propres donn\u00e9es # Mode debug setup_logging(level=logging.DEBUG) # Avec fichier de log setup_logging(level=logging.INFO, log_file=\"trip.log\")","title":"\ud83d\udd17 Prochaines \u00e9tapes"}]}